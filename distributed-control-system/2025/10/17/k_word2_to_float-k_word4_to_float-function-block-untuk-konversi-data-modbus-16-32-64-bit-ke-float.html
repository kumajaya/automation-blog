<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>K_WORD2_TO_FLOAT &amp; K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT | Technical &amp; Sustainability Digest</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="K_WORD2_TO_FLOAT &amp; K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Konversi register Modbus tidak sesederhana membaca angka. Perbedaan endianness, addressing, dan varian protokol kerap menimbulkan kebingungan di lapangan. Artikel ini memperkenalkan K_WORD2_TO_FLOAT dan K_WORD4_TO_FLOAT sebagai solusi praktis dan konsisten." />
<meta property="og:description" content="Konversi register Modbus tidak sesederhana membaca angka. Perbedaan endianness, addressing, dan varian protokol kerap menimbulkan kebingungan di lapangan. Artikel ini memperkenalkan K_WORD2_TO_FLOAT dan K_WORD4_TO_FLOAT sebagai solusi praktis dan konsisten." />
<meta property="og:site_name" content="Technical &amp; Sustainability Digest" />
<meta property="og:image" content="https://images.unsplash.com/photo-1531668383211-64743e924c66?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxjYWJsZXxlbnwwfHx8fDE3NjA3MTc0MzV8MA&ixlib=rb-4.1.0&q=80&w=2000" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-10-17T17:00:07+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://images.unsplash.com/photo-1531668383211-64743e924c66?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxjYWJsZXxlbnwwfHx8fDE3NjA3MTc0MzV8MA&ixlib=rb-4.1.0&q=80&w=2000" />
<meta property="twitter:title" content="K_WORD2_TO_FLOAT &amp; K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-10-17T17:00:07+00:00","datePublished":"2025-10-17T17:00:07+00:00","description":"Konversi register Modbus tidak sesederhana membaca angka. Perbedaan endianness, addressing, dan varian protokol kerap menimbulkan kebingungan di lapangan. Artikel ini memperkenalkan K_WORD2_TO_FLOAT dan K_WORD4_TO_FLOAT sebagai solusi praktis dan konsisten.","headline":"K_WORD2_TO_FLOAT &amp; K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT","image":"https://images.unsplash.com/photo-1531668383211-64743e924c66?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxjYWJsZXxlbnwwfHx8fDE3NjA3MTc0MzV8MA&ixlib=rb-4.1.0&q=80&w=2000","mainEntityOfPage":{"@type":"WebPage","@id":"/distributed-control-system/2025/10/17/k_word2_to_float-k_word4_to_float-function-block-untuk-konversi-data-modbus-16-32-64-bit-ke-float.html"},"url":"/distributed-control-system/2025/10/17/k_word2_to_float-k_word4_to_float-function-block-untuk-konversi-data-modbus-16-32-64-bit-ke-float.html"}</script>
<!-- End Jekyll SEO tag -->
<link id="main-stylesheet" rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Technical &amp; Sustainability Digest" /><!-- Dark Mode Detection -->
<script>
  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    document.documentElement.classList.add('dark-mode');
  }
</script>

<!-- PrismJS Syntax Highlighting Theme + Plugins -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/themes/prism-coy.min.css" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.css" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.css" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/command-line/prism-command-line.min.css" crossorigin="anonymous">

<!-- KaTeX (Math Typesetting Engine) -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.css" crossorigin="anonymous">

<!-- Font Awesome Icon Suite -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" crossorigin="anonymous" referrerpolicy="no-referrer" />

<!-- Dukungan favicon -->
<link rel="icon" type="image/png" sizes="16x16" href="/assets/media/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/media/favicon-32x32.png">
<link rel="shortcut icon" href="/assets/media/favicon.ico">

<style>
/* Reduce site title line-height and bottom margin */
.site-header .wrapper {
  display: flex;
  align-items: center;
  justify-content: space-between;
  height: 60px;
  padding: 0 1rem;
}
.site-title {
  margin: 0;
  font-size: 1.5rem;
  line-height: 1.2;
  font-weight: bold;
  text-decoration: none;
  color: inherit;
}
.site-title:hover,
.site-title:focus {
  text-decoration: none;
  color: inherit;
}

/* Post header left-align */
.post-header {
  text-align: left !important;
  padding-left: 0;
  border-bottom: 1px solid var(--border-color, #e0e0e0);
}
.post-category a {
  text-decoration: none;
}
.post-category a:hover,
.post-category a:focus {
  text-decoration: none;
  color: inherit;
}
.post-title {
  text-align: left !important;
  margin-left: 0;
}

/* Hide Ghost-specific elements */
.kg-card, .kg-file-card, .kg-audio-card, .kg-audio-card *, .scroll-button, .scroll-button svg, .gh-sidebar {
  display: none !important;
  visibility: hidden !important;
  opacity: 0 !important;
  pointer-events: none !important;
}

/* Native Audio Player Styling */
.native-audio-wrapper {
  margin: 1.5rem 0;
}

.native-audio-wrapper audio {
  width: 100%;
}

.audio-title {
  font-size: 1rem;
  font-weight: 600;
  color: #333;
  margin-bottom: 0.5rem;
  line-height: 1.4;
}

/* Mermaid Diagram Styling */
.mermaid {
  font-family: 'Segoe UI', sans-serif;
  background: rgba(255,255,255,0.9) !important;
  margin: 2.5rem auto;
  padding: 1.8rem;
  overflow: visible;
  text-align: center;
  opacity: 0;
  transition: opacity 0.5s ease-in;
}
.mermaid.is-ready { opacity: 1; }

/* Node & Label Styling */
.mermaid .node rect, .mermaid .node circle, .mermaid .node polygon, .mermaid .actor {
  fill: #ffffff;
  stroke: #3b82f6;
  stroke-width: 2.2px;
  rx: 8px; ry: 8px;
  filter: drop-shadow(0 2px 3px rgba(59,130,246,0.12)) drop-shadow(0 1px 1px rgba(59,130,246,0.1));
  transition: all 0.25s ease;
}
.mermaid .node text, .mermaid .label, .mermaid .label text {
  color: #1f2937;
  font-weight: 600;
  letter-spacing: 0.25px;
  line-height: 1.5;
}

/* Arrow & Edge Styling */
.mermaid .marker, .mermaid .arrowheadPath, .mermaid .arrowhead path { fill: #3b82f6 !important; stroke: none !important; }
.mermaid .edgePath path, .mermaid .path { stroke: #3b82f6; stroke-width: 2.6px; stroke-linecap: round; }
.mermaid path, .mermaid line { stroke-width: 1.5px !important; }

/* Diagram Title */
.mermaid .title, .mermaid .title text { font-weight: 600; color: #1e40af; }

/* Dark Mode Overrides */
.dark-mode .mermaid {
  background: rgba(17,24,39,0.85) !important;
  box-shadow: 0 4px 6px -1px rgba(0,0,0,0.2), 0 10px 15px -3px rgba(0,0,0,0.25);
}
.dark-mode .mermaid .node rect, .dark-mode .mermaid .node circle, .dark-mode .mermaid .node polygon, .dark-mode .mermaid .actor {
  fill: #111827;
  stroke: #60a5fa;
  filter: drop-shadow(0 2px 3px rgba(96,165,250,0.2)) drop-shadow(0 1px 1px rgba(96,165,250,0.15));
}
.dark-mode .mermaid .node text, .dark-mode .mermaid .label, .dark-mode .mermaid .label text { color: #f3f4f6; }
.dark-mode .mermaid .edgePath path, .dark-mode .mermaid .path { stroke: #60a5fa; }
.dark-mode .mermaid .title, .dark-mode .mermaid .title text { color: #93c5fd; }

/* Responsive Mermaid Adjustments */
@media (max-width: 768px) {
  .mermaid { padding: 1.2rem; border-radius: 10px; }
  .mermaid .label, .mermaid .node text, .mermaid .label text { font-size: 1.15rem !important; }
}

/* Table Styling */
table td, table th { border: 1px solid #e0e0e0; }
table tr:nth-child(even) { background-color: #f9f9f9; }
table td:first-child, table th:first-child { padding-left: 0.75em !important; }
table th { background-color: #222149; color: #fff !important; font-weight: bold; }
</style>
</head>
<body><header class="site-header">

  <div class="wrapper">
    <a class="site-title" rel="author" href="/">Technical &amp; Sustainability Digest</a>
      <nav class="site-nav">
        <input type="checkbox" id="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon"></span>
        </label>

        <div class="nav-items">
  <a class="nav-item" href="/about/">About</a>
</div>

      </nav>
  </div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    
    

    
    <div class="post-category" style="text-transform:uppercase; font-size:0.875rem; margin-bottom:0.25rem;">
      <a href="/categories/distributed-control-system/" itemprop="articleSection">
        Distributed Control System
      </a>
    </div>
    

    <h1 class="post-title p-name" itemprop="name headline">K_WORD2_TO_FLOAT &amp; K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT</h1>
    <div class="post-meta">
      <time class="dt-published" datetime="2025-10-17T17:00:07+00:00" itemprop="datePublished">
        October 17, 2025
      </time>
      <div class="force-inline post-authors">
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Ketut Kumajaya</span></span>
      </div>
      
      <div class="force-inline post-authors">
        <span class="reading-time">7 min read</span>
      </div>
      
    </div>
  </header>

  
  <p class="post-excerpt" itemprop="description">
    Konversi register Modbus tidak sesederhana membaca angka. Perbedaan endianness, addressing, dan varian protokol kerap menimbulkan kebingungan di lapangan. Artikel ini memperkenalkan K_WORD2_TO_FLOAT dan K_WORD4_TO_FLOAT sebagai solusi praktis dan konsisten.

  </p>
  

  
  <figure class="post-feature-image" style="margin-top:1rem;">
    <img src="https://images.unsplash.com/photo-1531668383211-64743e924c66?crop=entropy&cs=tinysrgb&fit=max&fm=jpg&ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxjYWJsZXxlbnwwfHx8fDE3NjA3MTc0MzV8MA&ixlib=rb-4.1.0&q=80&w=2000" alt="K_WORD2_TO_FLOAT & K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT" itemprop="image">
    
    <figcaption style="font-size:0.875rem; color:#6b7280; margin-top:0.25rem;">
      <p><span style="white-space: pre-wrap;">Photo by </span><a href="https://unsplash.com/@possessedphotography?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit"><span style="white-space: pre-wrap;">Possessed Photography</span></a><span style="white-space: pre-wrap;"> / </span><a href="https://unsplash.com/?utm_source=ghost&amp;utm_medium=referral&amp;utm_campaign=api-credit"><span style="white-space: pre-wrap;">Unsplash</span></a></p>

    </figcaption>
    
  </figure>
  

  <div class="post-content e-content" itemprop="articleBody">
    
<p><strong>Dari register mentah ke nilai proses — menjembatani protokol klasik dengan kebutuhan data modern.</strong></p>
<p><em>Ditulis oleh Ketut Kumajaya | 17 Oktober 2025</em></p>
<h2 id="latar-belakang">Latar Belakang</h2>
<p>Modbus adalah protokol komunikasi klasik yang diperkenalkan sejak akhir 1970‑an dan hingga kini tetap menjadi standar de facto di berbagai sistem industri. Kesederhanaan dan keterbukaannya membuat Modbus terus digunakan secara luas, baik pada perangkat lama maupun perangkat modern, mulai dari PLC hingga flowmeter.</p>
<p>Namun, karena Modbus hanya mendefinisikan pertukaran data dalam bentuk register 16‑bit, interpretasi data bernilai 32‑bit atau 64‑bit memerlukan mekanisme konversi tambahan. Tantangan umum yang muncul meliputi perbedaan <strong>endianness</strong>, perbedaan <strong>addressing</strong>, serta variasi <strong>hardware layer</strong> dan <strong>varian protokol</strong>.</p>
<h3 id="endianness">Endianness</h3>
<p>Endianness adalah urutan penyimpanan byte atau word dalam data biner:</p>
<ul>
<li><strong>Big‑endian</strong>: byte paling signifikan (MSB) disimpan lebih dulu.</li>
<li><strong>Little‑endian</strong>: byte paling signifikan disimpan paling akhir.</li>
</ul>
<h4 id="contoh-pada-modbus-32%E2%80%91bit">Contoh pada Modbus 32‑bit</h4>
<p>Nilai 1234.56 (FLOAT 32‑bit) dapat dikirim sebagai dua register 16‑bit:</p>
<table>
<thead>
<tr>
<th>Word Order</th>
<th>Register1</th>
<th>Register2</th>
<th>Keterangan</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big‑endian (MSB dulu)</td>
<td>0x449A</td>
<td>0x51EC</td>
<td>MSB → LSB</td>
</tr>
<tr>
<td>Little‑endian (LSB dulu)</td>
<td>0x51EC</td>
<td>0x449A</td>
<td>LSB → MSB</td>
</tr>
</tbody>
</table>
<h4 id="catatan-untuk-64%E2%80%91bit">Catatan untuk 64‑bit</h4>
<p>Pada data 64‑bit, variasi urutan bisa terjadi baik di level register maupun byte, sehingga interpretasi lebih kompleks.</p>
<h4 id="praktik-lapangan">Praktik Lapangan</h4>
<p>Jika hasil konversi tidak sesuai ekspektasi, langkah pertama yang umum dilakukan adalah <strong>menukar urutan register</strong>.</p>
<blockquote>
<p>Pemahaman mengenai endianness ini penting karena menjadi salah satu sumber kesalahan paling sering saat integrasi perangkat Modbus lintas vendor.</p>
</blockquote>
<h3 id="addressing">Addressing</h3>
<p>Selain endianness, Modbus juga memiliki perbedaan sistem penomoran alamat register:</p>
<ul>
<li><strong>Zero‑based addressing</strong>: register pertama ditandai sebagai alamat 0.</li>
<li><strong>One‑based addressing</strong>: register pertama ditandai sebagai alamat 1.</li>
</ul>
<p>Akibatnya, dapat terjadi perbedaan satu offset antara dokumentasi perangkat dan implementasi di SCADA/DCS. Misalnya, dokumentasi menyebutkan data di register 40001, tetapi pada sistem zero‑based harus diakses pada alamat 40000.</p>
<p>Perbedaan addressing ini sering menjadi sumber kebingungan saat integrasi, sehingga penting untuk selalu memverifikasi konvensi yang digunakan oleh perangkat maupun sistem SCADA/DCS.</p>
<h3 id="hardware-layer-dan-varian-modbus">Hardware Layer dan Varian Modbus</h3>
<p>Modbus hadir dalam beberapa varian:</p>
<ul>
<li><strong>Modbus RTU</strong>: berjalan di atas RS‑232/RS‑485 dengan format biner yang efisien, paling umum digunakan di lapangan.</li>
<li><strong>Modbus ASCII</strong>: juga berbasis serial, data dikirim dalam teks ASCII, lebih mudah dibaca manusia tetapi jarang dipakai di aplikasi modern.</li>
<li><strong>Modbus TCP/IP</strong>: berjalan di atas Ethernet, menggunakan MBAP header menggantikan CRC, umum pada perangkat generasi baru.</li>
<li><strong>Modbus RTU over TCP</strong>: frame RTU (lengkap dengan CRC) ditransmisikan melalui TCP tanpa MBAP header. Biasanya digunakan untuk kompatibilitas dengan perangkat lama melalui jaringan IP.</li>
</ul>
<p>Perbedaan antara <strong>Modbus TCP/IP</strong> dan <strong>Modbus RTU over TCP</strong> sangat penting dipahami, karena driver atau library harus sesuai dengan format frame yang digunakan. Pemilihan varian yang tepat memastikan komunikasi berjalan konsisten di berbagai perangkat dan sistem.</p>
<h3 id="catatan-tambahan">Catatan Tambahan</h3>
<ul>
<li>Pada Modbus RTU, integritas data dijaga dengan CRC di level frame.</li>
<li>Pada Modbus TCP/IP, CRC tidak digunakan karena protokol TCP/IP sudah memiliki mekanisme pemeriksaan integritas bawaan (checksum, sequence number, retransmission). MBAP header menggantikan CRC dalam frame TCP/IP.</li>
<li>Frame Modbus RTU juga dapat ditransmisikan melalui media nirkabel seperti <strong>LoRa</strong> dalam mode <em>transparent</em>. Dalam hal ini, LoRa hanya berfungsi sebagai saluran komunikasi, sementara integritas data tetap dijaga oleh CRC Modbus.</li>
</ul>
<hr />

<h2 id="kword2tofloat">K_WORD2_TO_FLOAT</h2>
<p>Function Block ini digunakan untuk menggabungkan dua register UINT menjadi nilai FLOAT. FB ini menjadi baseline parsing untuk data 16‑bit maupun 32‑bit, baik ketika perangkat mengirimkan data dalam format IEEE 754 maupun sebagai akumulator numerik.</p>
<figure style="display: flex; flex-direction: column; align-items: center; margin: 20px 0;">
  <div class="mermaid" style="width:70%; max-width:700px; font-size:16px;">
    %%{init: {'themeVariables': { 'fontSize': '16px', 'primaryColor': '#e8f0fe', 'edgeLabelBackground':'#ffffff'}}}%%
    flowchart TD
            A["Start: Baca Register Modbus<br />IN0 UINT LSB<br />IN1 UINT MSB"] --&gt; B{Cek Endianness<br />Hasil sesuai?}
            B --&gt;|Ya| C["Gabung ke 32-bit<br />Temp32 = IN0 + IN1 &lt;&lt; 16"]
            B --&gt;|Tidak - Endian salah| D["Tukar Urutan<br />Swap IN0 ↔ IN1<br />Ulangi Cek"]
            D --&gt; B
            C --&gt; E{"D = 0?"}
            E --&gt;|Ya| F["OUT = 0.0<br />Proteksi Div-by-Zero"]
            E --&gt;|Tidak| G{IEE = TRUE?}
            G --&gt;|Ya| H["Mode IEEE 754<br />OUT = GETFLOAT(Temp32) / D"]
            G --&gt;|Tidak| I["Mode Numerik<br />OUT = Temp32 as LONG / D"]
            H --&gt; J["End: Output FLOAT<br />(Siap untuk Tampilan/Proses)"]
            I --&gt; J
            F --&gt; J
            classDef start fill:#e1f5fe,stroke:#333,stroke-width:2px
            classDef final fill:#c8e6c9,stroke:#333,stroke-width:2px
            classDef swap fill:#fff3e0,stroke:#333,stroke-width:2px
            classDef decision fill:#f3e5f5,stroke:#333,stroke-width:2px
            classDef process fill:#ffffff,stroke:#333,stroke-width:2px
            class A start
            class J final
            class D swap
            class B,E,G decision
            class C,F,H,I process
  </div>
  <figcaption style="text-align:center; font-size:13px; color:#555;">
    Gambar 1: Alur Konversi Register Modbus 32-bit ke FLOAT Menggunakan Function Block K_WORD2_TO_FLOAT
  </figcaption>
</figure>
<h3 id="fitur-utama">Fitur Utama</h3>
<ul>
<li>Mendukung data <strong>16‑bit</strong>: IN0 diisi, IN1 = 0, <code>IEE = FALSE</code>.</li>
<li>Mendukung data <strong>32‑bit</strong>: IN0 dan IN1 diisi sesuai register.</li>
<li>Mode <strong>IEEE 754</strong> (<code>IEE = TRUE</code>) atau mode <strong>numerik</strong> (<code>IEE = FALSE</code>).</li>
<li>Skala pembagi (<code>D</code>) dengan proteksi pembagian nol.</li>
<li>Fleksibel terhadap variasi endian antar perangkat.</li>
</ul>
<details>
<summary><strong>Klik untuk menampilkan kode K_WORD2_TO_FLOAT</strong></summary>
<pre><code class="language-pascal">(*
------------------------------------------------------------------------------
 FB Name     : K_WORD2_TO_FLOAT
 Purpose     : Konversi atau interpretasi 2 register UINT menjadi FLOAT
               - Mode numerik: gabungan register sebagai accumulator
               - Mode IEEE 754 FLOAT: interpretasi bit pattern sebagai IEEE 754
 Author      : Ketut Kumajaya
 Contributor : Copilot (Microsoft AI)
 Version     : 1.0
 Date        : 17/10/2025
 Input       : 
    IN0 (UINT) - LSB dari data Modbus
    IN1 (UINT) - MSB dari data Modbus
    D   (LONG) - skala pembagi (misalnya Wh ke kWh)
    IEE (BOOL) - TRUE untuk interpretasi IEEE 754 FLOAT
                 FALSE untuk konversi numerik dari accumulator
 Output      : 
    OUT (FLOAT) - hasil akhir
 Notes       : 
    - Cocok untuk perangkat yang mengirim data FLOAT 32-bit via Modbus
    - D diuji dan digunakan di kedua mode
    - Jika D = 0 maka OUT = 0.0 untuk mencegah pembagian nol
    - IEE = TRUE menggunakan GETFLOAT untuk interpretasi bit pattern
    - IEE = FALSE menghitung nilai sebagai integer lalu dibagi D
    - Urutan IN0 dan IN1 dapat disesuaikan jika perangkat menggunakan format endian berbeda
    - Jika hasil tidak sesuai, coba tukar IN0 dan IN1
    - FB ini tidak mendukung data 64-bit
    - Menggunakan SHL_DWORD dan DWORD untuk kompatibilitas Supcon
------------------------------------------------------------------------------
*)

FUNCTION_BLOCK K_WORD2_TO_FLOAT
VAR_INPUT
    IN0 : UINT; (* LSB *)
    IN1 : UINT; (* MSB *)
    D   : LONG; (* Skala pembagi *)
    IEE : BOOL; (* TRUE = interpretasi bit sebagai IEEE 754 FLOAT *)
END_VAR

VAR_OUTPUT
    OUT : FLOAT; (* Hasil akhir *)
END_VAR

VAR
    Temp32 : DWORD;
END_VAR

(* Gabungkan 2 UINT menjadi 32-bit bit pattern *)
Temp32 := ULONG_TO_DWORD(UINT_TO_ULONG(IN0));
Temp32 := Temp32 + SHL_DWORD(ULONG_TO_DWORD(UINT_TO_ULONG(IN1)), 16);

(* Interpretasi sesuai mode *)
IF D &lt;&gt; 0 THEN
    IF IEE THEN
        OUT := GETFLOAT(Temp32) / LONG_TO_FLOAT(D);
    ELSE
        OUT := LONG_TO_FLOAT(DWORD_TO_LONG(Temp32)) / LONG_TO_FLOAT(D);
    END_IF;
ELSE
    OUT := 0.0;
END_IF;
END_FUNCTION_BLOCK

</code></pre>
</details>
<hr />

<h2 id="kword4tofloat">K_WORD4_TO_FLOAT</h2>
<p>Function Block ini digunakan untuk menggabungkan empat register UINT menjadi nilai 64‑bit, kemudian dikonversi ke FLOAT untuk keperluan tampilan, trending, atau estimasi. FB ini umumnya dipakai untuk perangkat yang mengirimkan akumulator energi, counter besar, atau nilai kumulatif lainnya.</p>
<figure style="display: flex; flex-direction: column; align-items: center; margin: 20px 0;">
  <div class="mermaid" style="width:70%; max-width:700px; font-size:16px;">
    %%{init: {'themeVariables': { 'fontSize': '16px', 'primaryColor': '#e8f0fe', 'edgeLabelBackground':'#ffffff'}}}%%
    flowchart TD
            A["Start: Baca Register Modbus<br />IN0 UINT LSB Low<br />IN1 UINT MSB Low<br />IN2 UINT LSB High<br />IN3 UINT MSB High"] --&gt; B{Cek Endianness<br />Hasil sesuai?}
            B --&gt;|Ya| C["Gabung Low32 = IN1 &lt;&lt; 16 + IN0<br />High32 = IN3 &lt;&lt; 16 + IN2"]
            B --&gt;|Tidak - Endian salah| D["Tukar Urutan<br />Swap IN0 ↔ IN1 (Low)<br />Swap IN2 ↔ IN3 (High)<br />Ulangi Cek"]
            D --&gt; B
            C --&gt; E{"D = 0?"}
            E --&gt;|Ya| F["OUT = 0.0<br />Proteksi Div-by-Zero"]
            E --&gt;|Tidak| G["Hitung 64-bit ke FLOAT<br />OUT = (High32 as LONG * 4294967296.0 + Low32 as LONG) / D"]
            G --&gt; H["End: Output FLOAT<br />(Untuk Monitoring/Estimasi)"]
            F --&gt; H
            classDef start fill:#e1f5fe,stroke:#333,stroke-width:2px
            classDef final fill:#c8e6c9,stroke:#333,stroke-width:2px
            classDef swap fill:#fff3e0,stroke:#333,stroke-width:2px
            classDef decision fill:#f3e5f5,stroke:#333,stroke-width:2px
            classDef process fill:#ffffff,stroke:#333,stroke-width:2px
            class A start
            class H final
            class D swap
            class B,E decision
            class C,F,G process
  </div>
  <figcaption style="text-align:center; font-size:13px; color:#555;">
    Gambar 2: Alur Rekonstruksi Data 64-bit dari Empat Register Modbus ke FLOAT
  </figcaption>
</figure>
<h3 id="fitur-utama">Fitur Utama</h3>
<ul>
<li>Menggabungkan <strong>Low32</strong> dan <strong>High32</strong> secara manual.</li>
<li>Rumus: <code>OUT = (High32 × 2^32 + Low32) ÷ D</code>.</li>
<li>Proteksi pembagian nol.</li>
<li>Catatan presisi: konversi ke FLOAT 32‑bit dilakukan agar nilai dapat diproses di DCS. Hasil ini memadai untuk kebutuhan operasional sehari‑hari, tetapi tidak memenuhi standar akurasi untuk audit atau billing. Untuk keperluan tersebut, gunakan data 64‑bit asli dari perangkat.</li>
</ul>
<details>
<summary><strong>Klik untuk menampilkan kode K_WORD4_TO_FLOAT</strong></summary>
<pre><code class="language-pascal">(*
------------------------------------------------------------------------------
 FB Name     : K_WORD4_TO_FLOAT
 Purpose     : Menggabungkan 4 register UINT menjadi nilai FLOAT 64-bit
               - Low32 dan High32 dibaca terpisah lalu digabung manual
 Author      : Ketut Kumajaya
 Contributor : Copilot (Microsoft AI)
 Version     : 1.0
 Date        : 17/10/2025
 Input       : 
    IN0 (UINT) - LSB dari bagian bawah (Low32)
    IN1 (UINT) - MSB dari bagian bawah (Low32)
    IN2 (UINT) - LSB dari bagian atas (High32)
    IN3 (UINT) - MSB dari bagian atas (High32)
    D   (LONG) - skala pembagi (misalnya Wh ke kWh)
 Output      : 
    OUT (FLOAT) - hasil akhir
 Notes       : 
    - Cocok untuk perangkat yang mengirim data 64-bit integer via Modbus
    - Supcon tidak mendukung tipe data 64-bit, maka penggabungan dilakukan manual
    - OUT = (High32 × 4294967296.0 + Low32) ÷ D
    - Jika D = 0 maka OUT = 0.0 untuk mencegah pembagian nol
    - Jika hasil tidak sesuai, coba tukar IN0 dan IN1, atau IN2 dan IN3
    - Presisi terbatas karena hasil disimpan sebagai FLOAT 32-bit
    - Gunakan FLOAT hanya untuk tampilan atau estimasi, bukan akurasi billing
    - Untuk audit, pastikan urutan register sesuai dokumentasi perangkat
    - Menggunakan SHL_DWORD dan DWORD untuk kompatibilitas Supcon
------------------------------------------------------------------------------
*)

FUNCTION_BLOCK K_WORD4_TO_FLOAT
VAR_INPUT
    IN0 : UINT; (* LSB Low *)
    IN1 : UINT; (* MSB Low *)
    IN2 : UINT; (* LSB High *)
    IN3 : UINT; (* MSB High *)
    D   : LONG; (* Skala pembagi *)
END_VAR

VAR_OUTPUT
    OUT : FLOAT;
END_VAR

VAR
    Low32  : DWORD;
    High32 : DWORD;
END_VAR

(* Gabungkan masing-masing pasangan *)
Low32  := SHL_DWORD(ULONG_TO_DWORD(UINT_TO_ULONG(IN1)), 16) + ULONG_TO_DWORD(UINT_TO_ULONG(IN0));
High32 := SHL_DWORD(ULONG_TO_DWORD(UINT_TO_ULONG(IN3)), 16) + ULONG_TO_DWORD(UINT_TO_ULONG(IN2));

(* Hitung total sebagai FLOAT *)
IF D &lt;&gt; 0 THEN
    OUT := (LONG_TO_FLOAT(DWORD_TO_LONG(High32)) * 4294967296.0 + LONG_TO_FLOAT(DWORD_TO_LONG(Low32))) / LONG_TO_FLOAT(D);
ELSE
    OUT := 0.0;
END_IF;
END_FUNCTION_BLOCK
</code></pre>
</details>
<hr />

<h2 id="panduan-singkat-penggunaan">Panduan Singkat Penggunaan</h2>
<h3 id="kapan-menggunakan-kword2tofloat">Kapan menggunakan K_WORD2_TO_FLOAT</h3>
<ul>
<li><strong>16‑bit</strong>: isi IN0, set IN1 = 0, gunakan <code>IEE = FALSE</code>.</li>
<li><strong>32‑bit</strong>: isi IN0 dan IN1 sesuai register.
<ul>
<li>IEEE 754 → <code>IEE = TRUE</code>.</li>
<li>Numerik → <code>IEE = FALSE</code>.</li>
</ul>
</li>
<li>Jika hasil tidak sesuai, coba tukar IN0 dan IN1.</li>
</ul>
<p>FB ini ideal untuk parsing data register tunggal atau ganda yang umum ditemui pada sensor dan flowmeter.</p>
<h3 id="kapan-menggunakan-kword4tofloat">Kapan menggunakan K_WORD4_TO_FLOAT</h3>
<ul>
<li><strong>64‑bit</strong>: isi IN0–IN3 sesuai register.</li>
<li>Cocok untuk akumulator besar (misalnya energi, volume kumulatif, atau counter jarak jauh).</li>
<li>OUT hanya untuk monitoring, bukan billing.</li>
<li>Jika hasil tidak sesuai, coba tukar pasangan register.</li>
</ul>
<p>FB ini relevan untuk perangkat yang mengirimkan nilai kumulatif besar, dengan catatan hasil konversi hanya dipakai untuk tampilan dan analisis tren.</p>
<h3 id="catatan-umum">Catatan Umum</h3>
<ul>
<li><strong>D = 0 → OUT = 0.0</strong>.</li>
<li>Addressing dapat berbeda (0‑based vs 1‑based).</li>
<li>Endianness antar vendor tidak selalu sama.</li>
<li>Pembagi (<code>D</code>) didefinisikan sebagai <code>LONG</code> (32‑bit signed). Rentang ini sudah memadai untuk kebutuhan scaling Modbus, sekaligus lebih sederhana dibanding <code>ULONG</code> yang di Supcon memerlukan konversi tambahan.</li>
</ul>
<hr />

<h2 id="lanjutan">Lanjutan</h2>
<p>Setelah data akumulator berhasil direkonstruksi menjadi nilai FLOAT yang siap dipakai, langkah berikutnya sering kali adalah menghitung <strong>delta energi</strong> untuk kebutuhan laporan periodik, rekonsiliasi antar meter, maupun audit energi.</p>
<p>Untuk tujuan tersebut, tersedia Function Block <strong>K_ACCDELTA</strong> sebagai modul terpisah. FB ini dirancang untuk menghitung delta akumulator secara andal, dengan proteksi nilai negatif dan mekanisme <em>snapshot reset</em> untuk sinkronisasi baseline antar meter. Modul ini menjadi kelanjutan alami dari FB parsing (K_WORD2/4_TO_FLOAT), sehingga alur pengolahan data tetap modular dan konsisten.</p>
<p>→ <a href="https://automation.samatorgroup.com/blog/k_accdelta-function-block-untuk-perhitungan-delta-akumulator/" target="_blank">K_ACCDELTA: Function Block untuk Perhitungan Delta Akumulator</a></p>
<hr />

<h2 id="penutup">Penutup</h2>
<p>Konversi register Modbus membutuhkan ketelitian terhadap format data, endianness, addressing, dan varian protokol. Kedua Function Block di atas dirancang untuk menyajikan nilai proses secara konsisten dan dapat ditelusuri kembali, sekaligus mengakui batasan presisi ketika menggunakan FLOAT 32‑bit.</p>
<p>Dengan dokumentasi yang jelas dan logika yang eksplisit, konversi bukan sekadar kalkulasi teknis, melainkan sarana untuk memastikan operator, engineer, dan auditor memahami proses dengan cara yang sama. Transparansi inilah yang menjadikan integrasi data lebih andal dan berkelanjutan.</p>


  </div>

  <a class="u-url" href="/distributed-control-system/2025/10/17/k_word2_to_float-k_word4_to_float-function-block-untuk-konversi-data-modbus-16-32-64-bit-ke-float.html" hidden></a>
</article>

      </div>
    </main><link id="fa-stylesheet" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.0.0/css/all.min.css">

<footer class="site-footer h-card">
  <data class="u-url" value="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <ul class="contact-list">
          <li class="p-name">Ketut Kumajaya</li>
          <li><a class="u-email" href="mailto:ketut.kumajaya@gmail.com">ketut.kumajaya@gmail.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Technical &amp; Sustainability Digest adalah arsip konten blog internal Samator Group yang menampilkan wawasan teknis, perspektif keberlanjutan, dan solusi praktis berdasarkan pengalaman lapangan. Repositori ini menyimpan konten dalam bentuk statis, memungkinkan backup otomatis, publikasi via static site generator.
</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li>
    <a rel="me" href="https://github.com/kumajaya/automation-blog" target="_blank" title="Repositori Automation Blog di GitHub">
      <span class="grey fa-brands fa-github fa-lg"></span>
    </a>
  </li><li>
    <a rel="me" href="https://x.com/ketutkumajaya" target="_blank" title="Ketut Kumajaya at X (formerly Twitter)">
      <span class="grey fa-brands fa-x-twitter fa-lg"></span>
    </a>
  </li>
  <li>
    <a href="/feed.xml" target="_blank" title="Subscribe to syndication feed">
      <svg class="svg-icon grey" viewbox="0 0 16 16">
        <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
          11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
          13.806c0-1.21.983-2.195 2.194-2.195zM10.606
          16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
        />
      </svg>
    </a>
  </li>
</ul>
</div>

  </div>

</footer>
<!-- PrismJS: Core syntax highlighting engine and plugins -->
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/prism.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/autoloader/prism-autoloader.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/toolbar/prism-toolbar.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/copy-to-clipboard/prism-copy-to-clipboard.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/line-numbers/prism-line-numbers.min.js"></script>
<script defer src="https://cdn.jsdelivr.net/npm/prismjs@1.30.0/plugins/command-line/prism-command-line.min.js"></script>

<script defer>
  window.addEventListener('DOMContentLoaded', () => {
    // Configure Prism Autoloader
    if (Prism.plugins.autoloader) {
      Prism.plugins.autoloader.languages_path = 'https://cdn.jsdelivr.net/npm/prismjs@1.30.0/components/';
    }

    // Add line numbers to all code blocks
    document.querySelectorAll('pre[class*=language-]').forEach(node => {
      node.classList.add('line-numbers');
    });

    // Trigger syntax highlighting
    Prism.highlightAll();
  });
</script>

<!-- KaTeX: Load math typesetting engine + auto-render -->
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/katex.min.js" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.22/dist/contrib/auto-render.min.js" crossorigin="anonymous"></script>

<script defer>
  document.addEventListener("DOMContentLoaded", () => {
    renderMathInElement(document.body, {
      delimiters: [
        {left: "$$", right: "$$", display: true},   // Block
        {left: "$", right: "$", display: false},     // Inline
        {left: "\\(", right: "\\)", display: false},
        {left: "\\[", right: "\\]", display: true}
      ]
    });
  });
</script>

<!-- Mermaid.js: Initialize diagrams -->
<script defer src="https://cdn.jsdelivr.net/npm/mermaid@11.9.0/dist/mermaid.min.js" crossorigin="anonymous"></script>
<script defer>
  window.addEventListener('DOMContentLoaded', () => {
    if (!window.mermaid) return;

    mermaid.initialize({
      startOnLoad: false,        // Manual rendering
      theme: 'base',
      fontFamily: 'Segoe UI, sans-serif',
      securityLevel: 'loose',
      themeVariables: {
        primaryColor: '#f0f7ff',
        primaryBorderColor: '#3b82f6'
      }
    });

    // Lazy-load observer for Mermaid diagrams
    const observer = new IntersectionObserver((entries, obs) => {
      entries.forEach(async entry => {
        if (entry.isIntersecting) {
          const el = entry.target;
          if (!el.id) el.id = `mermaid-diagram-${Math.random().toString(36).substr(2, 9)}`;
          await mermaid.run({ querySelector: `#${el.id}` });
          el.classList.add('is-ready');
          obs.unobserve(el);
        }
      });
    }, { rootMargin: '100px' });

    document.querySelectorAll('.mermaid').forEach(el => observer.observe(el));
  });
</script>

<!-- Audio Card Enhancement: Replace Ghost audio cards with native players -->
<script defer>
  document.addEventListener("DOMContentLoaded", function () {
    document.querySelectorAll(".kg-audio-card").forEach(function (card) {
      const audio = card.querySelector("audio");
      const title = card.querySelector(".kg-audio-title")?.textContent || "";
      const src = audio?.getAttribute("src");

      if (!src) return;

      // Buat elemen player
      const nativePlayer = document.createElement("audio");
      nativePlayer.setAttribute("controls", "");
      nativePlayer.setAttribute("preload", "metadata");

      const source = document.createElement("source");
      source.setAttribute("src", src);
      source.setAttribute("type", "audio/mpeg");
      nativePlayer.appendChild(source);

      // Tambahkan fallback sebagai node teks
      nativePlayer.appendChild(document.createTextNode(
        "Browser Anda tidak mendukung pemutar audio atau file tidak tersedia."
      ));

      // Bungkus semua dalam wrapper
      const wrapper = document.createElement("div");
      wrapper.className = "native-audio-wrapper";

      // Tambahkan caption di atas player
      if (title) {
        const caption = document.createElement("div");
        caption.className = "audio-title";
        caption.textContent = title;
        wrapper.appendChild(caption);
      }

      wrapper.appendChild(nativePlayer);

      // Tambahkan metadata untuk audit/logging
      wrapper.setAttribute("data-audio-source", src);
      wrapper.setAttribute("data-audio-title", title);

      // Ganti elemen Ghost dengan versi native
      card.replaceWith(wrapper);
    });
  });
</script>
</body>

</html>
