<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="https://kumajaya.github.io/automation-blog/feed.xml" rel="self" type="application/atom+xml" /><link href="https://kumajaya.github.io/automation-blog/" rel="alternate" type="text/html" /><updated>2025-10-18T19:25:22+00:00</updated><id>https://kumajaya.github.io/automation-blog/feed.xml</id><title type="html">Technical &amp;amp; Sustainability Digest</title><subtitle>Technical &amp; Sustainability Digest adalah arsip konten blog internal Samator Group yang menampilkan wawasan teknis, perspektif keberlanjutan, dan solusi praktis berdasarkan pengalaman lapangan. Repositori ini menyimpan konten dalam bentuk statis, memungkinkan backup otomatis, publikasi via static site generator.
</subtitle><author><name>Ketut Kumajaya</name><email>ketut.kumajaya@gmail.com</email></author><entry><title type="html">K_WORD2_TO_FLOAT &amp;amp; K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT</title><link href="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/17/k_word2_to_float-k_word4_to_float-function-block-untuk-konversi-data-modbus-16-32-64-bit-ke-float.html" rel="alternate" type="text/html" title="K_WORD2_TO_FLOAT &amp;amp; K_WORD4_TO_FLOAT: Function Block untuk Konversi Data Modbus 16/32/64‑bit ke FLOAT" /><published>2025-10-17T17:00:07+00:00</published><updated>2025-10-17T17:00:07+00:00</updated><id>https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/17/k_word2_to_float-k_word4_to_float-function-block-untuk-konversi-data-modbus-16-32-64-bit-ke-float</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/17/k_word2_to_float-k_word4_to_float-function-block-untuk-konversi-data-modbus-16-32-64-bit-ke-float.html"><![CDATA[<p><strong>Dari register mentah ke nilai proses — menjembatani protokol klasik dengan kebutuhan data modern.</strong></p>
<p><em>Ditulis oleh Ketut Kumajaya — 17 Oktober 2025</em></p>
<h2 id="latar-belakang">Latar Belakang</h2>
<p>Modbus adalah protokol komunikasi klasik yang diperkenalkan sejak akhir 1970‑an dan hingga kini tetap menjadi standar de facto di berbagai sistem industri. Kesederhanaan dan keterbukaannya membuat Modbus terus digunakan secara luas, baik pada perangkat lama maupun perangkat modern, mulai dari PLC hingga flowmeter.</p>
<p>Namun, karena Modbus hanya mendefinisikan pertukaran data dalam bentuk register 16‑bit, interpretasi data bernilai 32‑bit atau 64‑bit memerlukan mekanisme konversi tambahan. Tantangan umum yang muncul meliputi perbedaan <strong>endianness</strong>, perbedaan <strong>addressing</strong>, serta variasi <strong>hardware layer</strong> dan <strong>varian protokol</strong>.</p>
<h3 id="endianness">Endianness</h3>
<p>Endianness adalah urutan penyimpanan byte atau word dalam data biner:</p>
<ul>
<li><strong>Big‑endian</strong>: byte paling signifikan (MSB) disimpan lebih dulu.</li>
<li><strong>Little‑endian</strong>: byte paling signifikan disimpan paling akhir.</li>
</ul>
<h4 id="contoh-pada-modbus-32%E2%80%91bit">Contoh pada Modbus 32‑bit</h4>
<p>Nilai 1234.56 (FLOAT 32‑bit) dapat dikirim sebagai dua register 16‑bit:</p>
<table>
<thead>
<tr>
<th>Word Order</th>
<th>Register1</th>
<th>Register2</th>
<th>Keterangan</th>
</tr>
</thead>
<tbody>
<tr>
<td>Big‑endian (MSB dulu)</td>
<td>0x449A</td>
<td>0x51EC</td>
<td>MSB → LSB</td>
</tr>
<tr>
<td>Little‑endian (LSB dulu)</td>
<td>0x51EC</td>
<td>0x449A</td>
<td>LSB → MSB</td>
</tr>
</tbody>
</table>
<h4 id="catatan-untuk-64%E2%80%91bit">Catatan untuk 64‑bit</h4>
<p>Pada data 64‑bit, variasi urutan bisa terjadi baik di level register maupun byte, sehingga interpretasi lebih kompleks.</p>
<h4 id="praktik-lapangan">Praktik Lapangan</h4>
<p>Jika hasil konversi tidak sesuai ekspektasi, langkah pertama yang umum dilakukan adalah <strong>menukar urutan register</strong>.</p>
<blockquote>
<p>Pemahaman mengenai endianness ini penting karena menjadi salah satu sumber kesalahan paling sering saat integrasi perangkat Modbus lintas vendor.</p>
</blockquote>
<h3 id="addressing">Addressing</h3>
<p>Selain endianness, Modbus juga memiliki perbedaan sistem penomoran alamat register:</p>
<ul>
<li><strong>Zero‑based addressing</strong>: register pertama ditandai sebagai alamat 0.</li>
<li><strong>One‑based addressing</strong>: register pertama ditandai sebagai alamat 1.</li>
</ul>
<p>Akibatnya, dapat terjadi perbedaan satu offset antara dokumentasi perangkat dan implementasi di SCADA/DCS. Misalnya, dokumentasi menyebutkan data di register 40001, tetapi pada sistem zero‑based harus diakses pada alamat 40000.</p>
<p>Perbedaan addressing ini sering menjadi sumber kebingungan saat integrasi, sehingga penting untuk selalu memverifikasi konvensi yang digunakan oleh perangkat maupun sistem SCADA/DCS.</p>
<h3 id="hardware-layer-dan-varian-modbus">Hardware Layer dan Varian Modbus</h3>
<p>Modbus hadir dalam beberapa varian:</p>
<ul>
<li><strong>Modbus RTU</strong>: berjalan di atas RS‑232/RS‑485 dengan format biner yang efisien, paling umum digunakan di lapangan.</li>
<li><strong>Modbus ASCII</strong>: juga berbasis serial, data dikirim dalam teks ASCII, lebih mudah dibaca manusia tetapi jarang dipakai di aplikasi modern.</li>
<li><strong>Modbus TCP/IP</strong>: berjalan di atas Ethernet, menggunakan MBAP header menggantikan CRC, umum pada perangkat generasi baru.</li>
<li><strong>Modbus RTU over TCP</strong>: frame RTU (lengkap dengan CRC) ditransmisikan melalui TCP tanpa MBAP header. Biasanya digunakan untuk kompatibilitas dengan perangkat lama melalui jaringan IP.</li>
</ul>
<p>Perbedaan antara <strong>Modbus TCP/IP</strong> dan <strong>Modbus RTU over TCP</strong> sangat penting dipahami, karena driver atau library harus sesuai dengan format frame yang digunakan. Pemilihan varian yang tepat memastikan komunikasi berjalan konsisten di berbagai perangkat dan sistem.</p>
<h3 id="catatan-tambahan">Catatan Tambahan</h3>
<ul>
<li>Pada Modbus RTU, integritas data dijaga dengan CRC di level frame.</li>
<li>Pada Modbus TCP/IP, CRC tidak digunakan karena protokol TCP/IP sudah memiliki mekanisme pemeriksaan integritas bawaan (checksum, sequence number, retransmission). MBAP header menggantikan CRC dalam frame TCP/IP.</li>
<li>Frame Modbus RTU juga dapat ditransmisikan melalui media nirkabel seperti <strong>LoRa</strong> dalam mode <em>transparent</em>. Dalam hal ini, LoRa hanya berfungsi sebagai saluran komunikasi, sementara integritas data tetap dijaga oleh CRC Modbus.</li>
</ul>
<hr />

<h2 id="kword2tofloat">K_WORD2_TO_FLOAT</h2>
<p>Function Block ini digunakan untuk menggabungkan dua register UINT menjadi nilai FLOAT. FB ini menjadi baseline parsing untuk data 16‑bit maupun 32‑bit, baik ketika perangkat mengirimkan data dalam format IEEE 754 maupun sebagai akumulator numerik.</p>
<figure style="display: flex; flex-direction: column; align-items: center; margin: 20px 0;">
  <div class="mermaid" style="width:70%; max-width:700px; font-size:16px;">
    %%{init: {'themeVariables': { 'fontSize': '16px', 'primaryColor': '#e8f0fe', 'edgeLabelBackground':'#ffffff'}}}%%
    flowchart TD
            A["Start: Baca Register Modbus<br />IN0 UINT LSB<br />IN1 UINT MSB"] --&gt; B{Cek Endianness<br />Hasil sesuai?}
            B --&gt;|Ya| C["Gabung ke 32-bit<br />Temp32 = IN0 + IN1 &lt;&lt; 16"]
            B --&gt;|Tidak - Endian salah| D["Tukar Urutan<br />Swap IN0 ↔ IN1<br />Ulangi Cek"]
            D --&gt; B
            C --&gt; E{"D = 0?"}
            E --&gt;|Ya| F["OUT = 0.0<br />Proteksi Div-by-Zero"]
            E --&gt;|Tidak| G{IEE = TRUE?}
            G --&gt;|Ya| H["Mode IEEE 754<br />OUT = GETFLOAT(Temp32) / D"]
            G --&gt;|Tidak| I["Mode Numerik<br />OUT = Temp32 as LONG / D"]
            H --&gt; J["End: Output FLOAT<br />(Siap untuk Tampilan/Proses)"]
            I --&gt; J
            F --&gt; J
            classDef start fill:#e1f5fe,stroke:#333,stroke-width:2px
            classDef final fill:#c8e6c9,stroke:#333,stroke-width:2px
            classDef swap fill:#fff3e0,stroke:#333,stroke-width:2px
            classDef decision fill:#f3e5f5,stroke:#333,stroke-width:2px
            classDef process fill:#ffffff,stroke:#333,stroke-width:2px
            class A start
            class J final
            class D swap
            class B,E,G decision
            class C,F,H,I process
  </div>
  <figcaption style="text-align:center; font-size:13px; color:#555;">
    Gambar 1: Alur Konversi Register Modbus 32-bit ke FLOAT Menggunakan Function Block K_WORD2_TO_FLOAT
  </figcaption>
</figure>
<h3 id="fitur-utama">Fitur Utama</h3>
<ul>
<li>Mendukung data <strong>16‑bit</strong>: IN0 diisi, IN1 = 0, <code>IEE = FALSE</code>.</li>
<li>Mendukung data <strong>32‑bit</strong>: IN0 dan IN1 diisi sesuai register.</li>
<li>Mode <strong>IEEE 754</strong> (<code>IEE = TRUE</code>) atau mode <strong>numerik</strong> (<code>IEE = FALSE</code>).</li>
<li>Skala pembagi (<code>D</code>) dengan proteksi pembagian nol.</li>
<li>Fleksibel terhadap variasi endian antar perangkat.</li>
</ul>
<details>
<summary><strong>Klik untuk menampilkan kode K_WORD2_TO_FLOAT</strong></summary>
<pre><code class="language-pascal">(*
------------------------------------------------------------------------------
 FB Name     : K_WORD2_TO_FLOAT
 Purpose     : Konversi atau interpretasi 2 register UINT menjadi FLOAT
               - Mode numerik: gabungan register sebagai accumulator
               - Mode IEEE 754 FLOAT: interpretasi bit pattern sebagai IEEE 754
 Author      : Ketut Kumajaya
 Contributor : Copilot (Microsoft AI)
 Version     : 1.0
 Date        : 17/10/2025
 Input       : 
    IN0 (UINT) - LSB dari data Modbus
    IN1 (UINT) - MSB dari data Modbus
    D   (LONG) - skala pembagi (misalnya Wh ke kWh)
    IEE (BOOL) - TRUE untuk interpretasi IEEE 754 FLOAT
                 FALSE untuk konversi numerik dari accumulator
 Output      : 
    OUT (FLOAT) - hasil akhir
 Notes       : 
    - Cocok untuk perangkat yang mengirim data FLOAT 32-bit via Modbus
    - D diuji dan digunakan di kedua mode
    - Jika D = 0 maka OUT = 0.0 untuk mencegah pembagian nol
    - IEE = TRUE menggunakan GETFLOAT untuk interpretasi bit pattern
    - IEE = FALSE menghitung nilai sebagai integer lalu dibagi D
    - Urutan IN0 dan IN1 dapat disesuaikan jika perangkat menggunakan format endian berbeda
    - Jika hasil tidak sesuai, coba tukar IN0 dan IN1
    - FB ini tidak mendukung data 64-bit
    - Menggunakan SHL_DWORD dan DWORD untuk kompatibilitas Supcon
------------------------------------------------------------------------------
*)

FUNCTION_BLOCK K_WORD2_TO_FLOAT
VAR_INPUT
    IN0 : UINT; (* LSB *)
    IN1 : UINT; (* MSB *)
    D   : LONG; (* Skala pembagi *)
    IEE : BOOL; (* TRUE = interpretasi bit sebagai IEEE 754 FLOAT *)
END_VAR

VAR_OUTPUT
    OUT : FLOAT; (* Hasil akhir *)
END_VAR

VAR
    Temp32 : DWORD;
END_VAR

(* Gabungkan 2 UINT menjadi 32-bit bit pattern *)
Temp32 := ULONG_TO_DWORD(UINT_TO_ULONG(IN0));
Temp32 := Temp32 + SHL_DWORD(ULONG_TO_DWORD(UINT_TO_ULONG(IN1)), 16);

(* Interpretasi sesuai mode *)
IF D &lt;&gt; 0 THEN
    IF IEE THEN
        OUT := GETFLOAT(Temp32) / LONG_TO_FLOAT(D);
    ELSE
        OUT := LONG_TO_FLOAT(DWORD_TO_LONG(Temp32)) / LONG_TO_FLOAT(D);
    END_IF;
ELSE
    OUT := 0.0;
END_IF;
END_FUNCTION_BLOCK

</code></pre>
</details>
<hr />

<h2 id="kword4tofloat">K_WORD4_TO_FLOAT</h2>
<p>Function Block ini digunakan untuk menggabungkan empat register UINT menjadi nilai 64‑bit, kemudian dikonversi ke FLOAT untuk keperluan tampilan, trending, atau estimasi. FB ini umumnya dipakai untuk perangkat yang mengirimkan akumulator energi, counter besar, atau nilai kumulatif lainnya.</p>
<figure style="display: flex; flex-direction: column; align-items: center; margin: 20px 0;">
  <div class="mermaid" style="width:70%; max-width:700px; font-size:16px;">
    %%{init: {'themeVariables': { 'fontSize': '16px', 'primaryColor': '#e8f0fe', 'edgeLabelBackground':'#ffffff'}}}%%
    flowchart TD
            A["Start: Baca Register Modbus<br />IN0 UINT LSB Low<br />IN1 UINT MSB Low<br />IN2 UINT LSB High<br />IN3 UINT MSB High"] --&gt; B{Cek Endianness<br />Hasil sesuai?}
            B --&gt;|Ya| C["Gabung Low32 = IN1 &lt;&lt; 16 + IN0<br />High32 = IN3 &lt;&lt; 16 + IN2"]
            B --&gt;|Tidak - Endian salah| D["Tukar Urutan<br />Swap IN0 ↔ IN1 (Low)<br />Swap IN2 ↔ IN3 (High)<br />Ulangi Cek"]
            D --&gt; B
            C --&gt; E{"D = 0?"}
            E --&gt;|Ya| F["OUT = 0.0<br />Proteksi Div-by-Zero"]
            E --&gt;|Tidak| G["Hitung 64-bit ke FLOAT<br />OUT = (High32 as LONG * 4294967296.0 + Low32 as LONG) / D"]
            G --&gt; H["End: Output FLOAT<br />(Untuk Monitoring/Estimasi)"]
            F --&gt; H
            classDef start fill:#e1f5fe,stroke:#333,stroke-width:2px
            classDef final fill:#c8e6c9,stroke:#333,stroke-width:2px
            classDef swap fill:#fff3e0,stroke:#333,stroke-width:2px
            classDef decision fill:#f3e5f5,stroke:#333,stroke-width:2px
            classDef process fill:#ffffff,stroke:#333,stroke-width:2px
            class A start
            class H final
            class D swap
            class B,E decision
            class C,F,G process
  </div>
  <figcaption style="text-align:center; font-size:13px; color:#555;">
    Gambar 2: Alur Rekonstruksi Data 64-bit dari Empat Register Modbus ke FLOAT
  </figcaption>
</figure>
<h3 id="fitur-utama">Fitur Utama</h3>
<ul>
<li>Menggabungkan <strong>Low32</strong> dan <strong>High32</strong> secara manual.</li>
<li>Rumus: <code>OUT = (High32 × 2^32 + Low32) ÷ D</code>.</li>
<li>Proteksi pembagian nol.</li>
<li>Catatan presisi: konversi ke FLOAT 32‑bit dilakukan agar nilai dapat diproses di DCS. Hasil ini memadai untuk kebutuhan operasional sehari‑hari, tetapi tidak memenuhi standar akurasi untuk audit atau billing. Untuk keperluan tersebut, gunakan data 64‑bit asli dari perangkat.</li>
</ul>
<details>
<summary><strong>Klik untuk menampilkan kode K_WORD4_TO_FLOAT</strong></summary>
<pre><code class="language-pascal">(*
------------------------------------------------------------------------------
 FB Name     : K_WORD4_TO_FLOAT
 Purpose     : Menggabungkan 4 register UINT menjadi nilai FLOAT 64-bit
               - Low32 dan High32 dibaca terpisah lalu digabung manual
 Author      : Ketut Kumajaya
 Contributor : Copilot (Microsoft AI)
 Version     : 1.0
 Date        : 17/10/2025
 Input       : 
    IN0 (UINT) - LSB dari bagian bawah (Low32)
    IN1 (UINT) - MSB dari bagian bawah (Low32)
    IN2 (UINT) - LSB dari bagian atas (High32)
    IN3 (UINT) - MSB dari bagian atas (High32)
    D   (LONG) - skala pembagi (misalnya Wh ke kWh)
 Output      : 
    OUT (FLOAT) - hasil akhir
 Notes       : 
    - Cocok untuk perangkat yang mengirim data 64-bit integer via Modbus
    - Supcon tidak mendukung tipe data 64-bit, maka penggabungan dilakukan manual
    - OUT = (High32 × 4294967296.0 + Low32) ÷ D
    - Jika D = 0 maka OUT = 0.0 untuk mencegah pembagian nol
    - Jika hasil tidak sesuai, coba tukar IN0 dan IN1, atau IN2 dan IN3
    - Presisi terbatas karena hasil disimpan sebagai FLOAT 32-bit
    - Gunakan FLOAT hanya untuk tampilan atau estimasi, bukan akurasi billing
    - Untuk audit, pastikan urutan register sesuai dokumentasi perangkat
    - Menggunakan SHL_DWORD dan DWORD untuk kompatibilitas Supcon
------------------------------------------------------------------------------
*)

FUNCTION_BLOCK K_WORD4_TO_FLOAT
VAR_INPUT
    IN0 : UINT; (* LSB Low *)
    IN1 : UINT; (* MSB Low *)
    IN2 : UINT; (* LSB High *)
    IN3 : UINT; (* MSB High *)
    D   : LONG; (* Skala pembagi *)
END_VAR

VAR_OUTPUT
    OUT : FLOAT;
END_VAR

VAR
    Low32  : DWORD;
    High32 : DWORD;
END_VAR

(* Gabungkan masing-masing pasangan *)
Low32  := SHL_DWORD(ULONG_TO_DWORD(UINT_TO_ULONG(IN1)), 16) + ULONG_TO_DWORD(UINT_TO_ULONG(IN0));
High32 := SHL_DWORD(ULONG_TO_DWORD(UINT_TO_ULONG(IN3)), 16) + ULONG_TO_DWORD(UINT_TO_ULONG(IN2));

(* Hitung total sebagai FLOAT *)
IF D &lt;&gt; 0 THEN
    OUT := (LONG_TO_FLOAT(DWORD_TO_LONG(High32)) * 4294967296.0 + LONG_TO_FLOAT(DWORD_TO_LONG(Low32))) / LONG_TO_FLOAT(D);
ELSE
    OUT := 0.0;
END_IF;
END_FUNCTION_BLOCK
</code></pre>
</details>
<hr />

<h2 id="panduan-singkat-penggunaan">Panduan Singkat Penggunaan</h2>
<h3 id="kapan-menggunakan-kword2tofloat">Kapan menggunakan K_WORD2_TO_FLOAT</h3>
<ul>
<li><strong>16‑bit</strong>: isi IN0, set IN1 = 0, gunakan <code>IEE = FALSE</code>.</li>
<li><strong>32‑bit</strong>: isi IN0 dan IN1 sesuai register.
<ul>
<li>IEEE 754 → <code>IEE = TRUE</code>.</li>
<li>Numerik → <code>IEE = FALSE</code>.</li>
</ul>
</li>
<li>Jika hasil tidak sesuai, coba tukar IN0 dan IN1.</li>
</ul>
<p>FB ini ideal untuk parsing data register tunggal atau ganda yang umum ditemui pada sensor dan flowmeter.</p>
<h3 id="kapan-menggunakan-kword4tofloat">Kapan menggunakan K_WORD4_TO_FLOAT</h3>
<ul>
<li><strong>64‑bit</strong>: isi IN0–IN3 sesuai register.</li>
<li>Cocok untuk akumulator besar (misalnya energi, volume kumulatif, atau counter jarak jauh).</li>
<li>OUT hanya untuk monitoring, bukan billing.</li>
<li>Jika hasil tidak sesuai, coba tukar pasangan register.</li>
</ul>
<p>FB ini relevan untuk perangkat yang mengirimkan nilai kumulatif besar, dengan catatan hasil konversi hanya dipakai untuk tampilan dan analisis tren.</p>
<h3 id="catatan-umum">Catatan Umum</h3>
<ul>
<li><strong>D = 0 → OUT = 0.0</strong>.</li>
<li>Addressing dapat berbeda (0‑based vs 1‑based).</li>
<li>Endianness antar vendor tidak selalu sama.</li>
<li>Pembagi (<code>D</code>) didefinisikan sebagai <code>LONG</code> (32‑bit signed). Rentang ini sudah memadai untuk kebutuhan scaling Modbus, sekaligus lebih sederhana dibanding <code>ULONG</code> yang di Supcon memerlukan konversi tambahan.</li>
</ul>
<hr />

<h2 id="lanjutan">Lanjutan</h2>
<p>Setelah data akumulator berhasil direkonstruksi menjadi nilai FLOAT yang siap dipakai, langkah berikutnya sering kali adalah menghitung <strong>delta energi</strong> untuk kebutuhan laporan periodik, rekonsiliasi antar meter, maupun audit energi.</p>
<p>Untuk tujuan tersebut, tersedia Function Block <strong>K_ACCDELTA</strong> sebagai modul terpisah. FB ini dirancang untuk menghitung delta akumulator secara andal, dengan proteksi nilai negatif dan mekanisme <em>snapshot reset</em> untuk sinkronisasi baseline antar meter. Modul ini menjadi kelanjutan alami dari FB parsing (K_WORD2/4_TO_FLOAT), sehingga alur pengolahan data tetap modular dan konsisten.</p>
<p>→ <a href="https://automation.samatorgroup.com/blog/k_accdelta-function-block-untuk-perhitungan-delta-akumulator/" target="_blank">K_ACCDELTA: Function Block untuk Perhitungan Delta Akumulator</a></p>
<hr />

<h2 id="penutup">Penutup</h2>
<p>Konversi register Modbus membutuhkan ketelitian terhadap format data, endianness, addressing, dan varian protokol. Kedua Function Block di atas dirancang untuk menyajikan nilai proses secara konsisten dan dapat ditelusuri kembali, sekaligus mengakui batasan presisi ketika menggunakan FLOAT 32‑bit.</p>
<p>Dengan dokumentasi yang jelas dan logika yang eksplisit, konversi bukan sekadar kalkulasi teknis, melainkan sarana untuk memastikan operator, engineer, dan auditor memahami proses dengan cara yang sama. Transparansi inilah yang menjadikan integrasi data lebih andal dan berkelanjutan.</p>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="distributed-control-system" /><category term="Distributed Control System" /><category term="Practical Engineering" /><category term="Field Experience" /><summary type="html"><![CDATA[Konversi register Modbus tidak sesederhana membaca angka. Perbedaan endianness, addressing, dan varian protokol kerap menimbulkan kebingungan di lapangan. Artikel ini memperkenalkan K_WORD2_TO_FLOAT dan K_WORD4_TO_FLOAT sebagai solusi praktis dan konsisten.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1531668383211-64743e924c66?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxjYWJsZXxlbnwwfHx8fDE3NjA3MTc0MzV8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1531668383211-64743e924c66?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxjYWJsZXxlbnwwfHx8fDE3NjA3MTc0MzV8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">K_ACCDELTA: Function Block untuk Perhitungan Delta Akumulator</title><link href="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/16/k_accdelta-function-block-untuk-perhitungan-delta-akumulator.html" rel="alternate" type="text/html" title="K_ACCDELTA: Function Block untuk Perhitungan Delta Akumulator" /><published>2025-10-16T13:30:41+00:00</published><updated>2025-10-16T13:30:41+00:00</updated><id>https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/16/k_accdelta-function-block-untuk-perhitungan-delta-akumulator</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/16/k_accdelta-function-block-untuk-perhitungan-delta-akumulator.html"><![CDATA[<p><em>Ditulis oleh Ketut Kumajaya — 16 Oktober 2025</em></p>
<h3 id="latar-belakang">Latar Belakang</h3>
<p>Dalam sistem distribusi energi, sering kali terdapat perbedaan waktu pemasangan antara power meter pada sisi sumber dan sisi beban. Akibatnya, nilai akumulasi energi pada beban dapat lebih besar dibandingkan sumber, menghasilkan delta negatif yang tidak realistis.</p>
<p>Untuk mengatasi hal ini, Function Block <code>K_ACCDELTA</code> dikembangkan menggunakan Structured Text (ST) untuk menghitung delta akumulator secara andal, dilengkapi dengan proteksi terhadap nilai negatif dan mekanisme <em>snapshot reset</em> guna menyamakan baseline antar meter.</p>
<hr />

<h3 id="struktur-function-block">Struktur Function Block</h3>
<pre><code class="language-pascal">(*=============================================================================
  Function Block Name : K_ACCDELTA
  Author              : Ketut Kumajaya
  Contributor         : Copilot (Microsoft AI)
  Date Created        : 15/10/2025
  Version             : 1.0
  Description         : Menghitung delta antara dua akumulator energi dengan
                        penyimpanan nilai buffer antar siklus. Dapat berfungsi
                        sebagai delta satu power meter maupun sistem netting
                        (sumber–pengurang). Dirancang untuk sinkronisasi
                        pembacaan energi dari power meter yang tidak
                        terpasang serentak, dengan proteksi nilai negatif.
  Inputs              : srcCur - total energi sumber saat ini (FLOAT)
                        subCur - total energi pengurang saat ini (FLOAT)
                        srcBuf - nilai buffer sumber (FLOAT, disimpan di luar FB)
                        subBuf - nilai buffer pengurang (FLOAT, disimpan di luar FB)
                        reset  - TRUE untuk reset output &amp; snapshot awal (BOOL)
  Outputs             : dSrc   - delta energi sumber (FLOAT)
                        dSub   - delta energi pengurang (FLOAT)
                        eNet   - delta netting (sumber - pengurang) (FLOAT)
                        srcOut - snapshot nilai sumber untuk update buffer (FLOAT)
                        subOut - snapshot nilai pengurang untuk update buffer (FLOAT)
  Proteksi Audit      : - Nilai negatif dipaksa nol
                        - Snapshot hanya diperbarui saat reset
                        - Variabel buffer dikelola di luar Function Block
=============================================================================*)

FUNCTION_BLOCK K_ACCDELTA
VAR_INPUT
    srcCur : FLOAT;
    subCur : FLOAT;
    srcBuf : FLOAT;
    subBuf : FLOAT;
    reset  : BOOL;
END_VAR

VAR_OUTPUT
    dSrc   : FLOAT;
    dSub   : FLOAT;
    eNet   : FLOAT;
    srcOut : FLOAT;
    subOut : FLOAT;
END_VAR

VAR
END_VAR

IF NOT reset THEN
    (* Hitung delta terhadap nilai buffer *)
    dSrc := srcCur - srcBuf;
    IF dSrc &lt; 0.0 THEN dSrc := 0.0; END_IF;

    dSub := subCur - subBuf;
    IF dSub &lt; 0.0 THEN dSub := 0.0; END_IF;

    (* Netting antara sumber dan pengurang *)
    eNet := dSrc - dSub;
    IF eNet &lt; 0.0 THEN eNet := 0.0; END_IF;
ELSE
    (* Reset semua output *)
    dSrc := 0.0;
    dSub := 0.0;
    eNet := 0.0;
    (* Snapshot nilai sekarang untuk pembaruan buffer *)
    srcOut := srcCur; (* gunakan untuk update srcBuf eksternal *)
    subOut := subCur; (* gunakan untuk update subBuf eksternal *)
END_IF;

END_FUNCTION_BLOCK
</code></pre>
<hr />

<h3 id="penjelasan">Penjelasan</h3>
<p>Function Block ini dirancang <strong>minimalis</strong>, tanpa penyimpanan <em>state</em> internal. Seluruh baseline (<code>srcBuf</code>, <code>subBuf</code>) dikelola secara eksternal, sehingga blok ini dapat digunakan lintas plant tanpa perlu modifikasi besar.</p>
<ul>
<li><strong>Proteksi nilai negatif</strong> — memastikan delta energi tidak pernah bernilai negatif, menjaga akumulator tetap monoton meningkat.</li>
<li><strong>Snapshot reset</strong> — baseline hanya diperbarui saat reset dilakukan.</li>
<li><strong>Auditability</strong> — setiap aksi reset dapat dicatat sebagai baseline baru, menjaga transparansi pelaporan dan rekonsiliasi data.</li>
</ul>
<p>Selain mode <em>netting</em> (dua meter: sumber dan pengurang), blok ini juga mendukung mode <strong>single-meter delta</strong>. Pada mode ini, input <code>subCur</code> dan <code>subBuf</code> diisi <code>0.0</code>, sehingga <code>K_ACCDELTA</code> berfungsi sebagai kalkulator delta untuk satu power meter saja, di mana eNet = dSrc.</p>
<hr />

<h3 id="reset-logis-di-level-dcs">Reset Logis di Level DCS</h3>
<p>Reset pada <code>K_ACCDELTA</code> dilakukan <strong>di level DCS</strong>, bukan pada power meter fisik. Power meter terus mengakumulasi total energi tanpa pernah direset, sedangkan reset di DCS hanya menetapkan <strong>baseline baru</strong> sebagai titik awal perhitungan delta berikutnya tanpa mengubah nilai aktual di meter.</p>
<p>Reset ini berfungsi sebagai <strong>sinkronisasi baseline</strong> antar power meter, memastikan perhitungan delta tetap akurat meskipun waktu pemasangan atau status akumulasi antar meter berbeda.</p>
<p>Pendekatan ini memiliki beberapa keuntungan:</p>
<ul>
<li>Tidak memerlukan akses konfigurasi langsung ke power meter.</li>
<li>Aman terhadap kesalahan pembacaan maupun sistem billing.</li>
<li>Fleksibel dan dapat diterapkan lintas sistem.</li>
<li>Baseline reset dapat diaudit melalui rekam operasi DCS.</li>
</ul>
<p>Mekanisme reset logis ini <strong>tidak mengganggu logsheet maupun histori energi</strong>. Nilai akumulasi tetap tercatat normal, sementara baseline baru hanya memengaruhi perhitungan delta pada sisi DCS.</p>
<hr />

<h3 id="flowchart">Flowchart</h3>
<figure style="display: flex; flex-direction: column; align-items: center; margin: 20px 0;">
  <div class="mermaid" style="width:75%; max-width:700px; font-size:16px;">
%%{init: {'themeVariables': { 'fontSize': '14px', 'primaryColor': '#e8f0fe', 'edgeLabelBackground':'#ffffff'}}}%%
flowchart TD
    A["Mulai"] --&gt; B["Apakah reset = TRUE?"]
    B -- Ya --&gt; C["Snapshot buffer eksternal:<br />srcOut = srcCur<br />subOut = subCur"]
    B -- Tidak --&gt; D["Hitung delta sumber:<br />dSrc = srcCur - srcBuf"]
    D --&gt; E["Hitung delta pengurang:<br />dSub = subCur - subBuf"]
    E --&gt; F["Hitung energi bersih:<br />eNet = dSrc - dSub"]
    C --&gt; G["Kirim output:<br />dSrc, dSub, eNet, srcOut, subOut"]
    F --&gt; G
    G --&gt; H["Selesai"]
    A:::Pine
    B:::Peach
    C:::Ash
    D:::Ash
    E:::Ash
    F:::Ash
    G:::Ash
    H:::Pine
    classDef Peach stroke-width:2px, stroke-dasharray:none, stroke:#FBB35A, fill:#FFEFDB, color:#8F632D
    classDef Pine stroke-width:2px, stroke-dasharray:none, stroke:#254336, fill:#27654A, color:#FFFFFF
    classDef Ash stroke-width:2px, stroke-dasharray:none, stroke:#999999, fill:#EEEEEE, color:#000000
  </div>
  <figcaption style="text-align:center; font-size:13px; color:#555;">
    K_ACCDELTA: Perhitungan delta energi dengan proteksi negatif dan fungsi reset
  </figcaption>
</figure>
<hr />

<h3 id="kesimpulan">Kesimpulan</h3>
<p>Function Block <code>K_ACCDELTA</code> menghitung delta energi dengan proteksi nilai negatif dan mekanisme snapshot reset. Dengan desain yang minimalis dan modular, FB ini dapat digunakan baik untuk <strong>netting dua meter</strong> maupun <strong>single-meter delta</strong>, serta mendukung auditabilitas lintas plant. Reset dilakukan secara logis di DCS, memungkinkan pembaruan baseline kapan pun tanpa memengaruhi nilai akumulasi pada power meter.</p>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="distributed-control-system" /><category term="Distributed Control System" /><category term="Practical Engineering" /><category term="Field Experience" /><summary type="html"><![CDATA[Dirancang untuk menghitung delta energi atau akumulator dengan sinkronisasi baseline antar meter, tanpa mengganggu logsheet yang berjalan.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1604176857763-71877b24864e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDZ8fG1ldGVyfGVufDB8fHx8MTc2MDYxODMxOXww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1604176857763-71877b24864e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDZ8fG1ldGVyfGVufDB8fHx8MTc2MDYxODMxOXww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Menjaga Tulisan dari Ancaman Infrastruktur: Dari Ghost ke GitHub Pages</title><link href="https://kumajaya.github.io/automation-blog/practical-engineering/2025/10/14/menjaga-tulisan-dari-ancaman-infrastruktur-dari-ghost-ke-github-pages.html" rel="alternate" type="text/html" title="Menjaga Tulisan dari Ancaman Infrastruktur: Dari Ghost ke GitHub Pages" /><published>2025-10-14T11:36:06+00:00</published><updated>2025-10-14T11:36:06+00:00</updated><id>https://kumajaya.github.io/automation-blog/practical-engineering/2025/10/14/menjaga-tulisan-dari-ancaman-infrastruktur-dari-ghost-ke-github-pages</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/practical-engineering/2025/10/14/menjaga-tulisan-dari-ancaman-infrastruktur-dari-ghost-ke-github-pages.html"><![CDATA[<p><em>Ditulis oleh Ketut Kumajaya | 14 Oktober 2025</em></p>
<h3 id="pendahuluan">Pendahuluan</h3>
<p>Menulis blog itu sederhana. Tapi di balik kesederhanaannya, selalu ada satu kekhawatiran: bagaimana kalau <em>backbone</em> infrastruktur yang kita pakai tidak cukup kuat—dan suatu hari semua tulisan itu hilang begitu saja?</p>
<p>Saya masih punya akun WordPress lama. Masih aman, masih bisa diakses, tapi mulai terasa tidak nyaman karena gangguan iklan. Setelah itu, saya beralih ke blog pribadi dengan server berbayar yang saya kelola sendiri. Namun muncul kekhawatiran baru: bagaimana kalau suatu saat saya tidak lagi mampu membayar biaya server? Maka seluruh tulisan bisa hilang begitu saja.</p>
<p>Sekarang saya menulis di beberapa tempat—di blog pribadi, dan juga di blog dengan infrastruktur server yang disediakan tim IT korporasi. Tapi kekhawatiran itu tetap ada: bahwa suatu saat tulisan-tulisan itu bisa lenyap.</p>
<h4 id="pengetahuan-yang-hilang-usaha-yang-terulang">Pengetahuan yang Hilang, Usaha yang Terulang</h4>
<p>Jika itu terjadi, sekecil apa pun pengetahuan yang sudah terdokumentasi, tidak bisa lagi diwariskan. Orang lain akan mengulang usaha besar untuk hal yang sebenarnya sudah pernah terselesaikan.</p>
<p>Bagi saya, menulis bukan sekadar menyimpan kode atau konfigurasi, tetapi juga menyertakan narasi yang menjelaskan konteksnya. Program DCS, misalnya, akan jauh lebih mudah dipahami jika ada cerita di balik logikanya—kenapa dibuat seperti itu, dan bagaimana proses berpikirnya.</p>
<h4 id="mencari-jalan-agar-pengetahuan-tetap-hidup">Mencari Jalan agar Pengetahuan Tetap Hidup</h4>
<p>Dari kekhawatiran bahwa pengetahuan bisa hilang, saya mulai mencari pendekatan lain: menulis tetap di platform yang nyaman, di server mana pun, tetapi hasilnya disinkronkan ke layanan yang umurnya mungkin akan lebih panjang dari saya sendiri.</p>
<p>Saya tidak ingin generasi berikutnya masih harus belajar dari nol tentang <em>basic cryogenic</em>, <em>orifice flowmeter rescaling</em>, atau <em>performance curve analysis</em>, padahal semua itu sudah pernah kita lewati.</p>
<p>Karena itu, saya mulai melihat dokumentasi bukan hanya sebagai catatan kerja, tapi sebagai warisan yang harus dijaga keberlanjutannya.</p>
<hr />

<h3 id="github-tempat-menyimpan-warisan">GitHub: Tempat Menyimpan Warisan</h3>
<p>Sebagai pengguna GitHub sejak lama, banyak kode saya masih aman di sana—meskipun sempat muncul berbagai spekulasi setelah GitHub diakuisisi oleh Microsoft. Namun sejauh pengamatan saya, Microsoft bukan ancaman bagi proyek <em>open source</em>; justru kontribusinya semakin besar. Banyak aplikasi Microsoft kini bersifat <em>open source</em> dan berjalan lintas platform—baik di Windows maupun Linux (misalnya: VS Code atau .NET).</p>
<p>Kekuatan GitHub bukan hanya pada kemampuannya menyimpan kode, tetapi pada sistem <em>version control</em> di baliknya—<em>git</em>, ciptaan Linus Torvalds, sang pembuat Linux. Di mana pun saya menulis dokumen, pada dasarnya saya bisa menyinkronkannya ke GitHub secara otomatis. Setiap perubahan tercatat, setiap versi tersimpan.</p>
<p>Rasanya seperti memiliki <strong>arsip evolusi pengetahuan</strong> yang tidak akan pernah hilang.</p>
<hr />

<h3 id="praktiknya-blog-dan-mirroring">Praktiknya: Blog dan Mirroring</h3>
<p>Sekarang, ringkasannya seperti ini:</p>
<ul>
<li>Hal-hal umum dan tidak terlalu spesifik saya tulis di <a href="https://automation.samatorgroup.com/blog/" target="_blank">automation.samatorgroup.com/blog</a>.</li>
<li>Isinya saya <em>mirror</em> ke <a href="https://kumajaya.github.io/automation-blog/?ref=automation.samatorgroup.com" target="_blank">kumajaya.github.io/automation-blog</a> agar terjamin bisa diwariskan bahkan setelah saya tidak ada.</li>
</ul>
<p>Sinkronisasi diperiksa setiap hari secara otomatis oleh GitHub: jika ada perbedaan, sistem akan melakukan regenerasi konten. Dengan begitu, saya tetap bisa menulis di platform yang nyaman seperti Ghost, tetapi yakin bahwa hasilnya aman karena di-<em>mirror</em> setiap waktu. Otomasi terpenuhi—inovasi juga berjalan.</p>
<p>Saya selalu merasa <em>automation</em> itu lebih mudah diwujudkan karena hasilnya nyata, bisa diukur. Namun <em>innovation</em> sering kali lebih rumit—karena bagi saya, inovasi tidak harus selalu berbentuk alat atau sistem baru; kadang cukup dengan cara berpikir atau cara bekerja yang berubah.</p>
<p>Walau begitu, saya harus akui—tambahan kata <em>innovation</em> di nama departemen saya memang membawa beban tersendiri.</p>
<p>Semua teknik yang saya gunakan bersifat <em>open source</em>, dan bisa digunakan ulang siapa pun yang ingin melakukan hal serupa—karena pada akhirnya, pengetahuan baru akan benar-benar hidup jika bisa diwariskan dan digunakan kembali.</p>
<figure style="display: flex; flex-direction: column; align-items: center; margin: 20px 0;">
  <div class="mermaid" style="width:85%; max-width:800px; font-size:16px;">
    %%{init: {'themeVariables': { 'fontSize': '14px', 'primaryColor': '#e8f0fe', 'edgeLabelBackground':'#fff'}}}%%
    flowchart TB
        A["Ghost Blog<br />(automation.samatorgroup.com/blog)"]
        B["GitHub Pages<br />(kumajaya.github.io/automation-blog)"]
        A --&gt; E["Dokumentasi Internal<br />(Server Korporasi)"]
        E --&gt;|"Mirror otomatis"| B
        F["Cron Job &amp;<br />GitHub Action"] --&gt;|"Periksa &amp;<br />Regenerasi Harian"| B
        B --&gt; C["Pembaca Masa Depan"]
        A --&gt; D["Pembaca Masa Kini"]
        %% Definisi kelas
        classDef source fill:#1f77b4,stroke:#0d3d66,stroke-width:2px,color:#fff;
        classDef repo fill:#2ca02c,stroke:#145214,stroke-width:2px,color:#fff;
        classDef consumer fill:#ff7f0e,stroke:#a34b00,stroke-width:2px,color:#fff;
        classDef process fill:#9467bd,stroke:#4b2c6f,stroke-width:2px,color:#fff;
        %% Pemetaan node ke kelas
        class A source;
        class E source;
        class B repo;
        class C consumer;
        class D consumer;
        class F process;
  </div>
  <figcaption style="text-align:center; font-size:13px; color:#555;">
    Dari Ghost ke GitHub: Menjaga Pengetahuan Tetap Hidup
  </figcaption>
</figure>
<hr />

<h3 id="penutup-dokumentasi-sebagai-kolaborasi">Penutup: Dokumentasi sebagai Kolaborasi</h3>
<p>GitHub sebenarnya juga menyediakan layanan komersial. Jika para pengambil keputusan memahami potensi <em>git</em>, pendekatan ini sangat relevan untuk dokumentasi dengan <em>versioning control</em> yang ketat. Kita bisa bekerja bersama, mengembangkan ide yang sama, sambil tetap tahu siapa mengubah apa, kapan, dan kenapa.</p>
<p>Kode saya terbuka, bisa digunakan siapa saja, tanpa batasan. Namun, tentu saja tidak semua hal bisa dibuka—misalnya <em>API_KEY</em> blog pribadi, yang hanya saya miliki. Ghost tidak akan memberikan izin akses tanpa otorisasi, dan memang seharusnya begitu.</p>
<p>Karena pada akhirnya, sebagian pengetahuan memang harus dibuka agar bisa diwariskan, sementara sebagian yang lain tetap dijaga sebagai bentuk tanggung jawab.</p>
<p>Penasaran? Silakan kunjungi repo mirroring saya di <a href="https://github.com/kumajaya/automation-blog/tree/main?ref=automation.samatorgroup.com" target="_blank">GitHub</a>—mungkin Anda bisa fork, tambah kontribusi, atau adaptasi untuk proyek sendiri. Mari jaga warisan ini bersama!</p>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="practical-engineering" /><category term="Practical Engineering" /><category term="Team Collaboration" /><category term="Open Source" /><summary type="html"><![CDATA[Dari Ghost ke GitHub, dari tulisan menjadi arsip pengetahuan. Sebuah perjalanan mencari cara agar dokumentasi teknis bertahan melampaui umur server dan penulisnya.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1647696945040-56de84f73f5c?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGJvb2tzaGVsZiUyMGtub3dsZWRnZXxlbnwwfHx8fDE3NjA0MjE5Nzd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1647696945040-56de84f73f5c?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDF8fGJvb2tzaGVsZiUyMGtub3dsZWRnZXxlbnwwfHx8fDE3NjA0MjE5Nzd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Kepemimpinan Manusiawi di Era Otomasi</title><link href="https://kumajaya.github.io/automation-blog/team-collaboration/2025/10/11/kepemimpinan-manusiawi-di-era-otomasi.html" rel="alternate" type="text/html" title="Kepemimpinan Manusiawi di Era Otomasi" /><published>2025-10-11T16:54:00+00:00</published><updated>2025-10-11T16:54:00+00:00</updated><id>https://kumajaya.github.io/automation-blog/team-collaboration/2025/10/11/kepemimpinan-manusiawi-di-era-otomasi</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/team-collaboration/2025/10/11/kepemimpinan-manusiawi-di-era-otomasi.html"><![CDATA[<p><em>Ditulis oleh Ketut Kumajaya | 10 Oktober 2025</em></p>
<h3 id="pendahuluan-dunia-yang-berubah-cepat">Pendahuluan: Dunia yang Berubah Cepat</h3>
<p>Di Indonesia, laju adopsi AI di sektor knowledge work melonjak luar biasa—92% pekerja berbasis pengetahuan sudah menggunakan generative AI di tempat kerja (<a href="https://news.microsoft.com/source/asia/2025/03/12/creating-the-enablers-for-indonesias-ai-future/?ref=automation.samatorgroup.com" target="_blank">Microsoft, 2025</a>). Namun, sekitar 45% dari seluruh responden khawatir pekerjaan mereka lenyap akibat otomasi (<a href="https://www.microsoft.com/en-us/worklab/work-trend-index/ai-at-work-is-here-now-comes-the-hard-part?ref=automation.samatorgroup.com" target="_blank">Microsoft Work Trend Index, 2025</a>), termasuk di sektor manufaktur. Mesin pintar memang bekerja 24/7, tapi justru di sinilah peran manusia menjadi krusial—sebagai pemimpin perubahan, penjaga etika, dan arsitek sistem yang transparan. Perubahan besar dalam dunia industri tidak hanya terjadi pada teknologi, tetapi juga pada cara manusia memimpin dan membangun kepercayaan.</p>
<p>Kita sering berbicara tentang otomatisasi, digitalisasi, dan integrasi sistem, namun di tengah semua itu, faktor manusia tetap menjadi inti dari keberhasilan.</p>
<p>Banyak organisasi yang menyadari bahwa kemajuan sistem tidak selalu diikuti oleh kemajuan budaya kerja. Beberapa masih terjebak pada pola lama — mengukur efektivitas dari seberapa keras tekanan diberikan, bukan dari seberapa besar potensi manusia tumbuh di dalamnya. Padahal, di era yang semakin terhubung dan cerdas ini, <strong>pendekatan berbasis kekuasaan mulai kehilangan relevansinya.</strong></p>
<p>Kepemimpinan yang efektif tidak lagi diukur dari kemampuan mengontrol, tetapi dari kemampuan <strong>membangun kepercayaan dan menumbuhkan rasa memiliki.</strong> Dalam konteks inilah, pendekatan manusiawi menjadi kebutuhan, bukan pilihan. Bukan karena lebih lembut, tetapi karena lebih berkelanjutan.</p>
<hr />

<h3 id="dari-gaya-otoriter-ke-gaya-kolaboratif">Dari Gaya Otoriter ke Gaya Kolaboratif</h3>
<p>Dalam banyak organisasi industri, kepemimpinan masih sering dipahami sebagai kemampuan memberi perintah dan memastikan semuanya berjalan sesuai target. Pendekatan ini memang terbukti efektif pada masa ketika informasi bergerak lambat dan struktur organisasi bersifat hierarkis. Namun, dalam dunia yang semakin cepat dan kompleks—termasuk otomasi AI yang ambil alih tugas rutin—gaya seperti itu justru menjadi hambatan.</p>
<p>Kepemimpinan berbasis otoritas sering kali menghasilkan kepatuhan, tetapi jarang menumbuhkan keterlibatan. Orang akan bekerja karena kewajiban, bukan karena keyakinan. Dan ketika kesalahan terjadi, yang muncul bukan pembelajaran, melainkan rasa takut. Padahal, inovasi hanya mungkin tumbuh di lingkungan yang memberi ruang untuk mencoba, keliru, lalu memperbaiki—apalagi saat AI gagal tangani aspek emosional seperti ketakutan job loss.</p>
<p>Banyak perusahaan besar mulai bergerak ke arah yang lebih kolaboratif:</p>
<ul>
<li><strong>Microsoft</strong> di bawah Satya Nadella mengubah kultur internal dari “know-it-all” menjadi “learn-it-all”, yang krusial untuk adaptasi AI—di mana 20-30% code sudah ditulis AI (<a href="https://www.cnbc.com/2025/04/29/satya-nadella-says-as-much-as-30percent-of-microsoft-code-is-written-by-ai.html?ref=automation.samatorgroup.com" target="_blank">CNBC, 2025</a>)—hasilnya, produktivitas tim naik signifikan di proyek otomasi.</li>
<li><strong>Google</strong> menemukan bahwa tim paling sukses bukan yang diisi oleh orang paling pintar, tetapi yang memiliki rasa aman untuk berbicara dan dihargai idenya (Project Aristotle: tim dengan psychological safety 2x lebih inovatif) (<a href="https://www.nytimes.com/2016/02/28/magazine/what-google-learned-from-its-quest-to-build-the-perfect-team.html?ref=automation.samatorgroup.com" target="_blank">NYTimes, 2016</a>).</li>
<li><strong>Toyota</strong> tetap mempertahankan prinsip <em>respect for people</em> bahkan di tengah automasi besar-besaran, di mana training kolaboratif kurangi resistensi karyawan terhadap robot AI.</li>
</ul>
<p>Perubahan arah ini menunjukkan hal yang sama: kekuatan organisasi tidak lagi ditentukan oleh struktur, melainkan oleh kualitas hubungan di dalamnya, terutama saat teknologi seperti AI ubah cara kerja sehari-hari.</p>
<hr />

<h3 id="contoh-global-lainnya">Contoh Global Lainnya</h3>
<p>Beberapa praktik lain di korporasi besar menegaskan tren kepemimpinan manusiawi, terutama saat otomasi AI ubah dinamika kerja:</p>
<ol>
<li>
<p><strong>Amazon – Two-Pizza Teams &amp; Leadership Principles</strong></p>
<ul>
<li>Tim kecil (seperti ukuran dua pizza) agar setiap anggota berkontribusi nyata, krusial di era warehouse automation di mana AI tangani logistik tapi butuh empati manusia untuk tim hybrid (<a href="https://medium.com/@garisri07/decoding-amazon-leadership-principles-2025-a-roadmap-for-aspiring-leaders-286b5c05fa17?ref=automation.samatorgroup.com" target="_blank">Medium, 2025</a>).</li>
<li><em>Leadership Principles</em> seperti <em>“Hire and Develop the Best”</em> dan <em>“Earn Trust”</em> naikkan engagement di proyek AI.</li>
</ul>
</li>
<li>
<p><strong>Netflix – Culture of Freedom and Responsibility</strong></p>
<ul>
<li>Otonomi besar untuk karyawan, plus tanggung jawab penuh—ini dorong kreativitas di pengembangan algoritma rekomendasi AI, di mana kebebasan eksperimen kurangi bias mesin.</li>
<li>Hasil: Konten inovatif seperti serial global, dengan turnover rendah meski disrupsi tech.</li>
</ul>
</li>
<li>
<p><strong>Patagonia – Employee-Centric Culture</strong></p>
<ul>
<li>Utamakan keseimbangan kerja-hidup, libatkan karyawan di keputusan lingkungan—bahkan saat adopsi tech sustainable seperti AI untuk supply chain, nilai manusia tetap prioritas (<a href="https://workvivo.com/blog/patagonia-values-culture-turnover/?ref=automation.samatorgroup.com" target="_blank">Workvivo, 2023</a>).</li>
<li>Buktinya: lebih dari 80% karyawan loyal, bantu perusahaan tahan guncangan otomasi industri.</li>
</ul>
</li>
<li>
<p><strong>Unilever – Transformational Leadership &amp; Employee Engagement</strong></p>
<ul>
<li>Pemimpin fokus pengembangan potensi tim via program engagement, integrasikan AI untuk efisiensi tapi dengan training manusiawi—seperti di proyek kolaboratif lintas negara ala Airbus (<a href="https://www.linkedin.com/posts/unilever_unilevernews-activity-7379200101845729280-3pFt?ref=automation.samatorgroup.com" target="_blank">LinkedIn, 2025</a>).</li>
<li>Dampak: Produktivitas naik 27% di era AI, sambil jaga inklusivitas budaya.</li>
</ul>
</li>
</ol>
<p>Praktik ini bukti: Di 2025, kepemimpinan manusiawi bukan tambahan, tapi inti kolaborasi human-AI.</p>
<hr />

<h3 id="menemukan-nilai-dari-lapangan">Menemukan Nilai dari Lapangan</h3>
<p>Dalam konteks kerja sehari-hari, hal ini terlihat sederhana. Ketika seseorang merasa pendapatnya dihargai, ia akan lebih terbuka menyampaikan masalah. Memberi tim ruang untuk memahami alasan di balik keputusan membuat mereka lebih bertanggung jawab terhadap hasilnya. Ketika tim merasa memiliki keputusan dan hasilnya, <em>sense of ownership</em> berkembang: mereka tidak hanya bekerja, tetapi juga menjaga kualitas dan hasil dengan rasa bangga. Selain itu, ketika kesalahan tidak langsung dihakimi, kualitas kerja justru meningkat karena setiap orang belajar dari pengalaman mereka sendiri.</p>
<p>Pendekatan ini bukan berarti lunak. Ia menempatkan manusia sebagai bagian dari sistem yang harus dipahami, bukan sekadar dikendalikan. Sebuah prinsip sederhana, namun relevan di hampir semua situasi:</p>
<blockquote>
<p><em>“Make each individual feel they are important and that their input is appreciated.”</em></p>
</blockquote>
<p>Rasa dihargai adalah bahan bakar paling kuat untuk membangun sistem yang benar-benar hidup. Pendekatan ini menunjukkan bahwa gaya kepemimpinan lama yang hanya mengandalkan otoritas dan kontrol mulai kehilangan relevansinya di dunia kerja modern, terutama saat tim menghadapi tantangan kompleks dan otomatisasi AI.</p>
<hr />

<h3 id="kepemimpinan-sebagai-tanggung-jawab-moral">Kepemimpinan sebagai Tanggung Jawab Moral</h3>
<p>Kepemimpinan sering dipersepsikan sebagai posisi, padahal yang lebih penting adalah pengaruh. Seseorang bisa punya jabatan tinggi, tapi tak tinggalkan dampak positif. Sebaliknya, individu tanpa jabatan formal bisa jadi teladan—karena konsistensi berpikir dan bertindak.</p>
<p>Menjadi pemimpin berarti memilih memengaruhi lingkungan, bukan sekadar menyesuaikan diri. Jika diberi tanggung jawab, ada kewajiban perbaiki yang bisa diperbaiki—bukan demi ego, tapi agar sistem lebih sehat dan produktif. Ini krusial di era otomasi: Leader harus pimpin etika AI, pastikan teknologi tak ciptakan ketakutan job loss, tapi justru dorong pertumbuhan bersama.</p>
<p>Seorang pemimpin matang tak tunggu suasana ideal untuk bertindak. Ia ciptakan suasana itu melalui pikiran terbuka, sikap konsisten, dan keyakinan bahwa perubahan kecil tapi benar lebih berarti daripada kepatuhan besar tapi kosong.</p>
<hr />

<h3 id="menuju-organisasi-yang-lebih-manusiawi">Menuju Organisasi yang Lebih Manusiawi</h3>
<p>Setiap organisasi adalah kumpulan manusia dengan tujuan bersama. Keberhasilan tidak ditentukan semata oleh teknologi, prosedur, atau target angka, melainkan oleh sejauh mana manusia di dalamnya merasa dihargai dan dilibatkan.</p>
<p>Ketika orang bekerja dalam lingkungan yang mempercayai mereka, potensi terbaik muncul dengan sendirinya. Dan ketika setiap individu merasa penting, organisasi tidak lagi berjalan berdasarkan instruksi, melainkan kesadaran bersama.</p>
<p>Kepemimpinan bukan tentang siapa yang paling benar, tetapi tentang siapa yang paling bertanggung jawab terhadap arah perubahan. Keberlanjutan organisasi diukur bukan dari seberapa cepat bergerak, tetapi seberapa bermakna langkah yang diambil bagi orang-orang di dalamnya—terutama saat otomasi ubah landscape kerja.</p>
<figure style="display: flex; flex-direction: column; align-items: center; margin: 20px 0;">
  <div class="mermaid" style="width:100%; max-width:800px; font-size:16px;">
    ---
    config:
      theme: base
    ---
    mindmap
      root((Kepemimpinan Manusiawi<br />di Era Otomasi))
        (Empati &amp; Kepercayaan)
          Rasa Aman untuk Berbicara
          Kurangi Ketakutan Job Loss
        (Kolaborasi)
          Amazon: Two-Pizza
          Netflix: Freedom
        (Etika &amp; Adaptasi)
          Pimpin Etika AI
          Training Hybrid Human-AI
        (Contoh Global)
          Microsoft: Learn-it-All
          Google: Psychological Safety
          Patagonia: Employee-Centric
        (Hasil)
          Inovasi Berkelanjutan
          Kesadaran Bersama
  </div>
  <figcaption style="text-align:center; font-size:13px; color:#555;">
    Mindmap Prinsip kepemimpinan Manusiawi di Era Otomasi
  </figcaption>
</figure>
<hr />

<h3 id="penutup">Penutup</h3>
<p>Pandangan tentang kepemimpinan manusiawi ini lahir dari observasi dan pengalaman di lapangan, di mana keputusan teknis dan interaksi manusia saling berkaitan.<br />
Teknologi dan sistem otomatisasi hanyalah alat; yang menentukan keberhasilan organisasi adalah cara manusia bekerja bersama dalam lingkungan yang aman, dihargai, dan termotivasi. Meskipun tantangan berubah cepat, pendekatan manusiawi membantu tim tetap kuat dan adaptif.</p>
<p>Kepemimpinan yang efektif di era modern bukan sekadar otoritas atau kontrol, tetapi tentang menciptakan ekosistem di mana setiap individu merasa penting, memiliki ruang untuk berkontribusi, dan bertanggung jawab terhadap hasil.<br />
Ini sejalan dengan praktik terbaik global, di mana perusahaan besar menekankan <em>psychological safety</em>, pemberdayaan tim, dan kolaborasi sebagai inti pertumbuhan berkelanjutan.</p>
<p>Mulailah hari ini: Evaluasi satu hubungan di tim Anda—bagaimana bisa lebih manusiawi di tengah arus otomasi?</p>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="team-collaboration" /><category term="Team Collaboration" /><category term="Leadership Human Centered" /><category term="Field Experience" /><category term="Practical Engineering" /><summary type="html"><![CDATA[Di era otomasi, kepemimpinan manusiawi menjadi kunci keberhasilan. Memahami, menghargai, dan memberdayakan individu di tim lebih efektif daripada sekadar kontrol. Praktik global dan pengalaman lapangan menunjukkan: organisasi tumbuh ketika setiap orang merasa penting dan didengar.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1594477898765-b9ad43ad9cfc?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDIwfHxjb2xsYWJvcmF0aXZlfGVufDB8fHx8MTc2MDE5MzU4Nnww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1594477898765-b9ad43ad9cfc?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDIwfHxjb2xsYWJvcmF0aXZlfGVufDB8fHx8MTc2MDE5MzU4Nnww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Masalah MOD dan Solusi IF-THEN-ELSE di Delta Horizon 16-bit</title><link href="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/08/masalah-mod-dan-solusi-if-then-else-di-delta-horizon-16-bit.html" rel="alternate" type="text/html" title="Masalah MOD dan Solusi IF-THEN-ELSE di Delta Horizon 16-bit" /><published>2025-10-08T18:12:48+00:00</published><updated>2025-10-08T18:12:48+00:00</updated><id>https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/08/masalah-mod-dan-solusi-if-then-else-di-delta-horizon-16-bit</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/08/masalah-mod-dan-solusi-if-then-else-di-delta-horizon-16-bit.html"><![CDATA[<p><em>Ditulis oleh Ketut Kumajaya | 08 Oktober 2025</em></p>
<h2 id="pengantar">Pengantar</h2>
<p>Dalam sistem DCS berbasis counter 16-bit, perhitungan delta sering menghadapi masalah rollover—nilai kembali ke nol setelah mencapai batas 65.535. Jika tidak ditangani dengan benar, kondisi ini menghasilkan loncatan nilai besar (false delta) yang mengganggu akumulasi waktu maupun totalisasi.</p>
<p>Artikel ini membahas pendekatan <strong>IF-THEN-ELSE wrap-aware</strong> yang diimplementasikan dalam Function Block <strong>K_DELTA</strong>, serta hasil validasinya terhadap anomali delta akibat rollover.</p>
<hr />

<h2 id="latar-belakang">Latar Belakang</h2>
<p>Loncatan delta terdeteksi di pengujian lapangan setelah berhari-hari operasi, ketika counter timer atau pulse mengalami <em>wrap</em>, menyebabkan selisih waktu palsu yang mengganggu akumulasi.</p>
<p>Solusi <em>wrap-aware delta</em> mengatasi ini dengan menangani kondisi <em>wrap</em> secara eksplisit, melengkapi strategi sebelumnya seperti <strong>K_ACCUM</strong> untuk distribusi waktu antar controller.</p>
<hr />

<h2 id="analisis-akar-masalah">Analisis Akar Masalah</h2>
<p>Rentang 16-bit membatasi counter pada nilai 0–65.535, di mana <em>rollover</em> menyebabkan <code>CURRENT &lt; PREVIOUS</code>.</p>
<p>Pendekatan naif menggunakan MOD — <code>(CURRENT + 65536 - PREVIOUS) MOD 65536</code> — gagal di kondisi anomali <em>non-monotonic</em> (misalnya glitch hardware), menghasilkan delta besar seperti <strong>65.486</strong>, interpretasi <em>wrap palsu</em> yang mempropagasi loncatan ke akumulator.</p>
<p>Pada DCS tanpa <em>auto-promotion</em>, perhitungan MOD juga rentan <em>overflow pre-mod</em>, memperbesar risiko delta negatif atau positif palsu setelah 65k pulsa.</p>
<hr />

<h2 id="perbandingan-pendekatan">Perbandingan Pendekatan</h2>
<p>MOD efisien karena tanpa percabangan kondisional, tetapi rawan loncatan di anomali akibat ambiguitas modulo pada penurunan nilai (delta &gt; separuh rentang 32.768).</p>
<p>Sebaliknya, IF-THEN-ELSE lebih eksplisit: langsung mengurangkan jika tidak <em>wrap</em>, atau menghitung sisa rentang + CURRENT + 1 jika <em>wrap</em>.</p>
<p>Keduanya menghasilkan nilai identik di kondisi normal, namun IF-THEN-ELSE unggul dalam proteksi (cutoff anomali) dan kemudahan <em>debugging</em> di DCS — memastikan akumulasi tetap terprediksi.</p>
<hr />

<h2 id="catatan-teknis">Catatan Teknis</h2>
<p><strong>K_DELTA versi 1.2</strong> mengadopsi pendekatan <strong>IF-THEN-ELSE wrap-aware</strong> dengan <em>cutoff</em> 60 detik untuk loncatan ekstrem, menggunakan tipe <strong>LONG</strong> agar aman di Supcon.</p>
<p>Pendekatan ini menghilangkan loncatan akibat MOD dan menstabilkan delta untuk akumulasi yang dapat diprediksi.</p>
<p>Perlu dicatat bahwa masalah loncatan nilai sebenarnya bukan spesifik masalah K_DELTA, melainkan digunakan sebagai contoh kasus untuk menjelaskan perbedaan perilaku antara operator <code>MOD</code> dan logika <code>IF-THEN-ELSE</code>.</p>
<p>Dalam sistem sebenarnya, K_DELTA berfungsi sebagai <em>time backbone</em> — modul pusat yang menyediakan nilai <em>delta waktu</em> secara global bagi berbagai Function Block lain seperti <code>K_ACCUM</code>. Dengan cara ini, setiap <code>K_ACCUM</code> tidak perlu lagi menghitung delta waktunya masing-masing, sehingga struktur kode menjadi lebih sederhana, efisien, dan mudah diaudit.</p>
<hr />

<h3 id="diagram-alur">Diagram Alur</h3>
<div style="display: flex; flex-direction: column; align-items: center;">
  <div class="mermaid" style="width:60%; max-width:none; font-size:14px;">
    %%{init: {'themeVariables': { 'primaryColor': '#e8f0fe', 'lineColor': '#333', 'fontSize': '14px', 'edgeLabelBackground':'#ffffff'}}}%%
    graph TD
        A["Input: TIMER_IN, LAST_IN"] --&gt; B{"TIMER_IN &gt;= LAST_IN?"}
        B --&gt;|<span style="color:green">Ya</span>| C["Δ := TIMER_IN - LAST_IN (LONG)"]
        B --&gt;|<span style="color:orange">Tidak</span>| D["Δ := (65535 - LAST_IN) + TIMER_IN + 1 (LONG)"]
        C --&gt; E{"Δ &gt; 60?"}
        D --&gt; E
        E --&gt;|<span style="color:green">Ya</span>| F["Δ := 0; ALARM_OUT := TRUE"]
        E --&gt;|<span style="color:orange">Tidak</span>| G["ALARM_OUT := FALSE"]
        F --&gt; H["Output: DELTA_OUT := UINT(Δ)"]
        G --&gt; H
        classDef startend fill:#d0e6ff,stroke:#004aad,stroke-width:2px,color:#000;
        classDef decision fill:#fff5cc,stroke:#ffb300,stroke-width:2px,color:#000;
        classDef alarm fill:#ffd6d6,stroke:#e60000,stroke-width:2px,color:#000;
        classDef process fill:#e8f0fe,stroke:#004aad,stroke-width:2px,color:#000;
        class A,H startend;
        class B,E decision;
        class C,D,G process;
        class F alarm;
  </div>
</div>
<hr />

<h2 id="validasi-independen-dengan-simulasi">Validasi Independen dengan Simulasi</h2>
<p>Simulasi pada lingkungan mirip PLC menunjukkan loncatan MOD pada <em>non-wrap decrease</em> (<code>delta = 65486 &gt; 32768</code>), sedangkan IF menghasilkan nilai yang sama namun dapat diproteksi dengan cutoff.</p>
<p>Tes konfirmasi membuktikan eliminasi loncatan dan akumulasi yang tetap stabil.</p>
<table>
<thead>
<tr>
<th>Deskripsi</th>
<th>CURRENT</th>
<th>PREVIOUS</th>
<th>Delta MOD</th>
<th>Delta IF</th>
<th>Match?</th>
<th>Catatan</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normal increase</td>
<td>100</td>
<td>50</td>
<td>50</td>
<td>50</td>
<td>Ya</td>
<td>Aman</td>
</tr>
<tr>
<td>Wrap-around</td>
<td>10</td>
<td>65530</td>
<td>16</td>
<td>16</td>
<td>Ya</td>
<td>Rollover benar</td>
</tr>
<tr>
<td>Non-wrap decrease (anomaly)</td>
<td>50</td>
<td>100</td>
<td>65486</td>
<td>65486</td>
<td>Ya</td>
<td><strong>Loncatan besar</strong> (&gt;32.768, wrap palsu)</td>
</tr>
<tr>
<td>Exact wrap</td>
<td>0</td>
<td>65535</td>
<td>1</td>
<td>1</td>
<td>Ya</td>
<td>Aman</td>
</tr>
<tr>
<td>No change</td>
<td>65535</td>
<td>65535</td>
<td>0</td>
<td>0</td>
<td>Ya</td>
<td>Stabil</td>
</tr>
</tbody>
</table>
<hr />

<h2 id="validasi-tambahan">Validasi Tambahan</h2>
<p>Pengujian lanjutan pada K_DELTA menunjukkan hasil konsisten dengan desain: <strong>tidak ada loncatan delta</strong> meski terjadi <em>wrap</em> atau <em>non-monotonic glitch</em>.</p>
<p>Simulasi dilakukan pada 1000 siklus penuh dengan <em>timer 16-bit rollover</em>, serta injeksi anomali penurunan acak (10%). Semua kasus menghasilkan delta stabil, cutoff bekerja sesuai ambang 60 detik, dan alarm aktif hanya pada kondisi valid.</p>
<table>
<thead>
<tr>
<th>Deskripsi</th>
<th>TIMER_IN</th>
<th>LAST_IN</th>
<th>Startup?</th>
<th>DELTA_OUT</th>
<th>ALARM_OUT</th>
<th>Raw Delta</th>
<th>Status</th>
</tr>
</thead>
<tbody>
<tr>
<td>Normal increase</td>
<td>100</td>
<td>50</td>
<td>No</td>
<td>50</td>
<td>False</td>
<td>50</td>
<td>OK</td>
</tr>
<tr>
<td>Wrap-around</td>
<td>10</td>
<td>65530</td>
<td>No</td>
<td>16</td>
<td>False</td>
<td>16</td>
<td>OK</td>
</tr>
<tr>
<td>Non-wrap decrease (anomaly)</td>
<td>50</td>
<td>100</td>
<td>No</td>
<td>0</td>
<td>True</td>
<td>65486</td>
<td>OK</td>
</tr>
<tr>
<td>Exact wrap</td>
<td>0</td>
<td>65535</td>
<td>No</td>
<td>1</td>
<td>False</td>
<td>1</td>
<td>OK</td>
</tr>
<tr>
<td>No change</td>
<td>65535</td>
<td>65535</td>
<td>No</td>
<td>0</td>
<td>False</td>
<td>0</td>
<td>OK</td>
</tr>
<tr>
<td>Startup</td>
<td>0</td>
<td>0</td>
<td>Yes</td>
<td>0</td>
<td>False</td>
<td>0</td>
<td>OK</td>
</tr>
<tr>
<td>Large delta &gt;60</td>
<td>200</td>
<td>100</td>
<td>No</td>
<td>0</td>
<td>True</td>
<td>100</td>
<td>OK</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>Hasil ringkas:</strong> Semua test pass 100%. Tidak ada loncatan, cutoff bekerja, dan akumulasi tetap konsisten hingga 1000 siklus penuh.<br />
Simulasi lanjutan menunjukkan <em>raw delta</em> besar (misalnya 65.486) dipotong otomatis menjadi nol dengan alarm aktif — <strong>tanpa propagasi loncatan ke akumulator</strong>.</p>
</blockquote>
<hr />

<h3 id="interpretasi">Interpretasi</h3>
<p>Pendekatan MOD cenderung menghasilkan delta besar di kondisi anomali karena ambiguitas hasil modulo.</p>
<p>Sementara kombinasi IF-THEN-ELSE dengan cutoff mencegah propagasi loncatan dan menjaga integritas akumulasi jangka panjang.</p>
<hr />

<h2 id="kesimpulan">Kesimpulan</h2>
<p>Loncatan delta pada counter 16-bit berhasil diatasi oleh <strong>K_DELTA versi 1.2</strong> melalui pendekatan <strong>IF-THEN-ELSE</strong>, yang menggantikan kelemahan MOD tanpa efek loncatan palsu.</p>
<p>Metode ini penting untuk menjaga keandalan sistem akumulasi dan runtime di lingkungan DCS yang sensitif terhadap rollover counter.</p>
<p><em>Catatan: Simulasi mengikuti aritmetika standar IEC 61131.</em></p>
<hr />

<details>
  <summary><strong>Appendix A — Listing Kode K_DELTA</strong></summary>
<pre><code class="language-pascal">(*==============================================================================
FB Name     : K_DELTA
Purpose     : Menghitung delta waktu wrap-aware dari timer utama (UINT 16-bit)
Author      : Ketut Kumajaya
Version     : 1.2 (IF-THEN-ELSE, no MOD)
Date        : 07/10/2025
Input       : TIMER_IN (UINT), LAST_IN (UINT)
Output      : DELTA_OUT (UINT), LAST_OUT (UINT), ALARM_OUT (BOOL)
Notes       : - IF-THEN-ELSE untuk hindari loncatan MOD
              - Cutoff 60 detik; LONG untuk Supcon-safe
              - Persisten global LAST_IN/OUT
==============================================================================*)

FUNCTION_BLOCK K_DELTA
VAR_INPUT
    TIMER_IN : UINT;
    LAST_IN  : UINT;
END_VAR
VAR_OUTPUT
    DELTA_OUT : UINT;
    LAST_OUT  : UINT;
    ALARM_OUT : BOOL;
END_VAR
VAR
    Delta       : LONG;
    StartupFlag : BOOL;
END_VAR

StartupFlag := g_bColdStartup OR g_bHotStartup OR g_bDownUsrPrgFlag OR g_bDownCfgFlag;

IF StartupFlag THEN
    Delta := 0;
    ALARM_OUT := FALSE;
    g_bColdStartup := FALSE;
    g_bHotStartup := FALSE;
    g_bDownUsrPrgFlag := FALSE;
    g_bDownCfgFlag := FALSE;
ELSE
    IF TIMER_IN &gt;= LAST_IN THEN
        Delta := ULONG_TO_LONG(UINT_TO_ULONG(TIMER_IN)) - ULONG_TO_LONG(UINT_TO_ULONG(LAST_IN));
    ELSE
        Delta := ULONG_TO_LONG(UINT_TO_ULONG(65535 - LAST_IN)) + ULONG_TO_LONG(UINT_TO_ULONG(TIMER_IN)) + 1;
    END_IF;

    IF Delta &gt; 60 THEN
        Delta := 0;
        ALARM_OUT := TRUE;
    ELSE
        ALARM_OUT := FALSE;
    END_IF;
END_IF;

DELTA_OUT := ULONG_TO_UINT(LONG_TO_ULONG(Delta));
LAST_OUT  := TIMER_IN;

END_FUNCTION_BLOCK
</code></pre>
</details>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="distributed-control-system" /><category term="Distributed Control System" /><category term="Field Experience" /><category term="Practical Engineering" /><summary type="html"><![CDATA[Pendekatan MOD sering dipakai untuk menghitung delta berbasis counter 16-bit di sistem DCS. Namun, metode ini rawan menghasilkan loncatan nilai saat terjadi anomali pembacaan.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1601397922721-4326ae07bbc5?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDZ8fG1hdGh8ZW58MHx8fHwxNzU5OTQzNjQ3fDA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1601397922721-4326ae07bbc5?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDZ8fG1hdGh8ZW58MHx8fHwxNzU5OTQzNjQ3fDA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Arsitektur Edge-to-Server untuk Integrasi Data Industri</title><link href="https://kumajaya.github.io/automation-blog/edge-computing/2025/10/07/arsitektur-edge-to-server-untuk-integrasi-data-industri.html" rel="alternate" type="text/html" title="Arsitektur Edge-to-Server untuk Integrasi Data Industri" /><published>2025-10-07T05:08:20+00:00</published><updated>2025-10-07T05:08:20+00:00</updated><id>https://kumajaya.github.io/automation-blog/edge-computing/2025/10/07/arsitektur-edge-to-server-untuk-integrasi-data-industri</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/edge-computing/2025/10/07/arsitektur-edge-to-server-untuk-integrasi-data-industri.html"><![CDATA[<p><em>Ditulis oleh Ketut Kumajaya | 6 Oktober 2025</em></p>
<h3 id="latar-belakang">Latar Belakang</h3>
<p>Dalam dunia otomasi industri, data proses bukan sekadar angka di layar; ia adalah dasar pengambilan keputusan bisnis.<br />
Dari pengalaman bertahun-tahun di lantai kontrol, beberapa masalah klasik sering muncul:</p>
<ul>
<li>Data DCS sulit diakses di luar jaringan unit produksi, atau hilang saat jaringan terganggu.</li>
<li>ERP membutuhkan data untuk analisis dan pelaporan, tapi tidak selalu membutuhkan data real-time.</li>
<li>Banyak sistem modern menerapkan push architecture, namun dalam praktik lapangan sering menghadapi tantangan saat jaringan putus atau SCADA restart.</li>
</ul>
<p>Solusi yang lebih tahan banting adalah mencatat data proses secara lokal di lapangan, menyimpannya dengan aman, lalu menariknya ke server hanya ketika diperlukan. Dengan cara ini, risiko kehilangan data berkurang drastis dan sistem tetap resilient.</p>
<h3 id="filosofi-pull-vs-push">Filosofi Pull vs Push</h3>
<blockquote>
<p>Dari pengalaman lapangan, push architecture sering menjadi rumit.<br />
Saat jaringan putus, data stagnan tanpa disadari. Restart SCADA bisa memutus aliran.<br />
Pull architecture lebih stabil: data dicatat lokal, server hanya menarik sesuai interval.<br />
Resilience lebih penting daripada kecepatan dalam operasi nyata. Kecepatan bisa ditunda, integritas tidak bisa ditawar.</p>
</blockquote>
<p>Dalam satu kasus nyata, jaringan antar-plant terputus selama 6 jam. Pada sistem push, histori hilang permanen. Pada sistem pull, edge tetap mencatat penuh. Begitu koneksi pulih, server menarik backlog, dan ERP tetap menerima histori lengkap tanpa celah.</p>
<hr />

<h3 id="arsitektur-sistem">Arsitektur Sistem</h3>
<p>Sistem ini dibagi menjadi dua lapisan utama: <strong>edge</strong> dan <strong>server</strong>.</p>
<p><strong>Edge computer</strong> ditempatkan di perbatasan antara dunia proses dan digital, seperti Raspberry Pi 4B dalam casing industrial Advantech UNO220, menjalankan Ubuntu Server headless. Perannya bukan sekadar gateway, melainkan <strong>pencatat data independen, pengolah awal, dan penghubung aman</strong> ke server pusat. Edge menyimpan buffer data beberapa bulan, sehingga meski jaringan terputus, histori tetap utuh.</p>
<p><strong>Server</strong> berjalan di VM Ubuntu Server yang juga headless. Ia bertindak sebagai <strong>relay dan integrator</strong>, menerima permintaan dari ERP atau Node‑RED, lalu meneruskannya ke edge sesuai lokasi. Server tidak perlu tahu detail teknis tiap edge, cukup berbicara dengan format JSON seragam dari proxy.</p>
<hr />

<h4 id="diagram-alur-sistem">Diagram Alur Sistem</h4>
<p>Diagram berikut memperlihatkan alur komunikasi:</p>
<ul>
<li><strong>DCS → Modbus RTU → Modbus TCP/RTU Gateway</strong>: data proses mentah keluar dari sistem kontrol.</li>
<li><strong>Rapid SCADA</strong> di edge mencatat data sebagai historian.</li>
<li><strong>Node‑RED</strong> di edge mengirim laporan otomatis atau status OS.</li>
<li><strong>Proxy Layer</strong> menjamin format JSON konsisten, menambahkan autentikasi dan flag audit.</li>
<li><strong>Server Node‑RED</strong> menerima permintaan dari ERP, lalu meneruskan ke proxy di edge.</li>
<li><strong>Grafana</strong> mengambil data dari proxy untuk visualisasi.</li>
<li><strong>Chat Server</strong> menerima laporan mandiri dari edge.</li>
</ul>
<div style="display: flex; flex-direction: column; align-items: center;">
    <div class="mermaid" style="width:100%; max-width:none; font-size:14px;">
    flowchart LR
     subgraph DCS_Side["Process"]
            DCS["DCS"]
      end
     subgraph Edge["    Edge Computer"]
            MB("Modbus RTU")
            MBD["Modbus TCP ↔ RTU"]
            RS["Rapid SCADA"]
            NR["Node-RED"]
            PL["Proxy Layer"]
      end
     subgraph Server["Server"]
            SNR["Node-RED"]
            SG["Grafana"]
            ERP["ERP System"]
            CHAT["Chat Server"]
      end
        MB --&gt; MBD
        MBD --&gt; RS
        NR --&gt; PL &amp; CHAT
        ERP --&gt; SNR
        SNR --&gt; PL
        PL --&gt; RS
        SG --&gt; PL
        DCS --&gt; MB
          DCS:::Ash
          MB:::Peach
          MBD:::Peach
          RS:::Peach
          NR:::Peach
          PL:::Peach
          SNR:::Sky
          SG:::Sky
          ERP:::Sky
          CHAT:::Sky
        classDef Rose stroke-width:2px, stroke-dasharray:none, stroke:#FF5978, fill:#FFDFE5, color:#8E2236
        classDef Peach stroke-width:2px, stroke-dasharray:none, stroke:#FBB35A, fill:#FFEFDB, color:#8F632D
        classDef Sky stroke-width:2px, stroke-dasharray:none, stroke:#374D7C, fill:#E2EBFF, color:#374D7C
        classDef Pine stroke-width:2px, stroke-dasharray:none, stroke:#254336, fill:#27654A, color:#FFFFFF
        classDef Ash stroke-width:2px, stroke-dasharray:none, stroke:#999999, fill:#EEEEEE, color:#000000
        style Server fill:transparent
        style Edge fill:transparent
        style DCS_Side fill:transparent
    </div>
</div>
<hr />

<h3 id="edge-layer">Edge Layer</h3>
<p>Edge computer berfungsi sebagai pencatat data independen, pengolah awal, sekaligus penghubung aman antara DCS dan server pusat. Untuk itu, beberapa layanan utama dijalankan secara paralel:</p>
<ul>
<li><strong>Rapid SCADA</strong> → mencatat data dari DCS sebagai historian.</li>
<li><strong>Node-RED</strong> → membuat auto report, memantau status OS, dan melakukan pengolahan sederhana sebelum data dikirim ke server.</li>
<li><strong>mbusbd</strong> → adapter yang memungkinkan Modbus RTU diakses bersama Rapid SCADA dan Node-RED tanpa konflik port.</li>
</ul>
<blockquote>
<p><strong>Advantech UNO220</strong> adalah casing standar industri yang dapat melengkapi Raspberry Pi 4B. Casing ini sudah termasuk pendingin pasif (<em>fanless cooling</em>), RTC Epson RX‑8010SJ‑B, TI TCA9554 I/O expander, Infineon OPTIGA™ TPM SLB9670 security chip, port serial RS‑232/RS‑485, dan dukungan Power over Ethernet (PoE).</p>
<p>Dukungan hardware tersebut sangat memadai, <strong>namun tetap membutuhkan konfigurasi software yang benar</strong> agar sistem berjalan stabil dan aman.<br />
Seluruh dukungan software tersedia di repositori penulis untuk memastikan integrasi berjalan mulus.</p>
</blockquote>
<h4 id="catatan-tentang-modbus-rtu">Catatan tentang Modbus RTU</h4>
<p>Meski sederhana, Modbus RTU berbasis RS‑485 justru memberi lapisan keamanan tambahan: tidak terekspos ke TCP/IP, stabil dengan pola master‑slave deterministik, dan mudah diaudit. Dengan gateway TCP/RTU di edge, DCS tetap terlindungi di domain serial, sementara server pusat tetap menerima data dalam format modern yang konsisten.</p>
<hr />

<h3 id="proxy-layer">Proxy Layer</h3>
<p>Proxy layer open source di edge:</p>
<ul>
<li>Menyediakan format JSON konsisten untuk server.</li>
<li>Menangani autentikasi: Rapid SCADA 5 (Basic Auth) vs Rapid SCADA 6 (session cookie).</li>
<li>Menambah keamanan: log akses, kontrol autentikasi, monitoring.</li>
</ul>
<blockquote>
<p>Server dan aplikasi lain (Node-RED, Grafana) dapat mengakses data tanpa mengetahui versi SCADA atau detail teknis edge.<br />
Open source, bebas lisensi, dan dapat disesuaikan sesuai kebutuhan — hasil development mandiri yang bisa terus dievolusi.</p>
</blockquote>
<hr />

<h3 id="server">Server</h3>
<p>Server berperan sebagai <strong>relay data dan integrator</strong>:</p>
<ul>
<li>ERP system mengirim REST → server meneruskan ke edge → hasil dikembalikan.</li>
<li>Node-RED dan Grafana mengambil data dengan cara seragam.</li>
<li>Chat server internal memungkinkan edge mengirim laporan performa atau status OS secara mandiri.</li>
</ul>
<p>ERP tidak butuh data real-time; cukup data 48 jam terakhir. Retry panggilan ERP diatur tim ERP — server tetap ringan dan fokus relay. Dengan pola ini, satu server bisa melayani puluhan edge tanpa bottleneck.</p>
<hr />

<h3 id="nilai-ekonomis">Nilai Ekonomis</h3>
<ul>
<li>Edge murah tapi cukup kuat: Raspberry Pi industrial, PC Windows, atau perangkat lain yang mendukung Modbus RTU.</li>
<li>Server dapat melayani banyak lokasi.</li>
<li>Pencatatan lokal mengurangi risiko downtime.</li>
<li>Open source → tanpa biaya lisensi.</li>
<li>Skalabilitas sederhana: menambah unit baru cukup edge minimal, atau komputer Windows yang ada + USB RS-485 converter → OS-independent.</li>
</ul>
<table>
<thead>
<tr>
<th>Komponen</th>
<th>Biaya</th>
<th>Fungsi Utama</th>
<th>Lisensi</th>
</tr>
</thead>
<tbody>
<tr>
<td>Edge (RPi)</td>
<td>Rendah</td>
<td>Pencatat &amp; gateway</td>
<td>Open source</td>
</tr>
<tr>
<td>Server (VM)</td>
<td>Sedang</td>
<td>Relay &amp; integrator</td>
<td>Open source</td>
</tr>
<tr>
<td>Proxy Layer</td>
<td>Nol</td>
<td>Format JSON &amp; keamanan</td>
<td>Open source</td>
</tr>
<tr>
<td>Rapid SCADA</td>
<td>Nol</td>
<td>Historian &amp; visualisasi</td>
<td>Open source</td>
</tr>
<tr>
<td>Node‑RED</td>
<td>Nol</td>
<td>Automasi &amp; REST handler</td>
<td>Open source</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Meski murah, sistem ini tidak murahan: dibangun dari pengalaman integrasi teruji.<br />
Vendor DCS dapat menawarkan solusi, dengan tantangan menghadirkan integrasi yang lebih luas, fleksibel, dan berjalan paralel dengan sistem yang sudah ada. Dengan begitu, ekosistem industri dapat tumbuh semakin terbuka, kolaboratif, dan berkelanjutan.</p>
</blockquote>
<hr />

<h3 id="penutup">Penutup</h3>
<p>Arsitektur ini lahir dari pengalaman lapangan sebagai system integrator yang ditempa oleh praktik nyata, bukan teori kelas. Setiap komponen — Rapid SCADA, Node-RED, ZeroTier, proxy layer — disatukan agar stabil, aman, dan saling memahami.</p>
<p>Sistem cukup sederhana untuk dipahami, tangguh, fleksibel, dan profesional.<br />
Setiap unit produksi mandiri, fleksibel dari sisi perangkat keras dan OS, tetap menjadi bagian dari ekosistem data aman yang efisien.</p>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="edge-computing" /><category term="Edge Computing" /><category term="Distributed Control System" /><category term="Field Experience" /><category term="Practical Engineering" /><summary type="html"><![CDATA[Dengan perangkat sederhana dan software open source, sistem ini menghadirkan integrasi data industri yang aman, efisien, dan berkelanjutan.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1639117474926-9e22670f6bf8?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDE2fHx0cmVuZHxlbnwwfHx8fDE3NTk3MDU1ODB8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1639117474926-9e22670f6bf8?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDE2fHx0cmVuZHxlbnwwfHx8fDE3NTk3MDU1ODB8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">K_LOOKUP_LINEAR: Function Block untuk Interpolasi Linear Dinamis</title><link href="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/04/k_lookup_linear-function-block-untuk-interpolasi-linear-dinamis.html" rel="alternate" type="text/html" title="K_LOOKUP_LINEAR: Function Block untuk Interpolasi Linear Dinamis" /><published>2025-10-04T06:04:05+00:00</published><updated>2025-10-04T06:04:05+00:00</updated><id>https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/04/k_lookup_linear-function-block-untuk-interpolasi-linear-dinamis</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/04/k_lookup_linear-function-block-untuk-interpolasi-linear-dinamis.html"><![CDATA[<p><em>Ditulis oleh Ketut P. Kumajaya | 4 Oktober 2025</em></p>
<h3 id="latar-belakang">Latar Belakang</h3>
<p>Interpolasi linear adalah metode sederhana namun krusial dalam otomasi proses. Banyak kurva performa peralatan—seperti garis surge centrifugal compressor, karakteristik valve, atau profil efisiensi pompa—tidak tersedia dalam bentuk persamaan matematis, melainkan tabel titik data.</p>
<p>Function Block <code>K_LOOKUP_LINEAR</code> dirancang di Supcon DCS menggunakan Structured Text (ST) untuk melakukan interpolasi linear berbasis array dinamis. Berbeda dengan <code>K_LIN_INTERP14</code> yang statis dengan 14 titik, FB ini mendukung hingga 32 titik referensi, dilengkapi proteksi multi‑lapis dan flag audit agar siap digunakan lintas plant.</p>
<p>Sebagai catatan, <code>K_LIN_INTERP14</code> telah diimplementasikan di salah satu plant untuk lookup kurva <strong>anti-surge</strong> dan terbukti stabil dalam operasi harian. Block ini sendiri merupakan implementasi bebas dari fungsi serupa yang tersedia di <strong>Yokogawa Centum VP</strong>, dan pengalaman lapangan inilah yang menjadi dasar pengembangan <code>K_LOOKUP_LINEAR</code> sebagai versi yang lebih fleksibel dan modular.</p>
<hr />

<h3 id="listing-function-block">Listing Function Block</h3>
<pre><code class="language-pascal">(*=============================================================================
  Function Block Name : K_LOOKUP_LINEAR
  Author              : Ketut P. Kumajaya
  Date Created        : 04/10/2025
  Description         : Interpolasi linear dinamis berbasis array referensi
                        dengan proteksi multi-lapis dan flag audit.
  Inputs              : Enable     - Aktivasi interpolasi (BOOL)
                        X          - Nilai input yang akan diinterpolasi (FLOAT)
                        N          - Jumlah titik referensi aktif (INT, min 2)
                        THRESHOLD  - Ambang deviasi audit (FLOAT)
                        X_REF      - array32FLOAT (koordinat X referensi)
                        Y_REF      - array32FLOAT (koordinat Y referensi)
  Outputs             : Y          - Hasil interpolasi linear (FLOAT)
                        X1_used    - Titik awal X interval aktif (FLOAT)
                        Y1_used    - Titik awal Y interval aktif (FLOAT)
                        X2_used    - Titik akhir X interval aktif (FLOAT)
                        Y2_used    - Titik akhir Y interval aktif (FLOAT)
                        Valid      - Flag validasi hasil interpolasi (BOOL)
                        AuditFlag  - Flag audit deviasi/ketidakrapihan data (BOOL)
                        DensityValid - Flag validasi monotoni X_REF (BOOL)
  Artefak Pairing     : array32FLOAT - ARRAY [0..31] OF FLOAT
  Proteksi Audit      : Clamp jika X di luar range; fallback pada interval
                        degenerat; AuditFlag aktif jika deviasi ekstrem atau
                        data tidak monoton; N dikunci dalam rentang aman.
=============================================================================*)

FUNCTION_BLOCK K_LOOKUP_LINEAR

VAR_INPUT
    Enable    : BOOL;
    X         : FLOAT;
    N         : INT;
    THRESHOLD : FLOAT;
    X_REF     : array32FLOAT;
    Y_REF     : array32FLOAT;
END_VAR

VAR_OUTPUT
    Y           : FLOAT;
    X1_used     : FLOAT;
    Y1_used     : FLOAT;
    X2_used     : FLOAT;
    Y2_used     : FLOAT;
    Valid       : BOOL;
    AuditFlag   : BOOL;
    DensityValid: BOOL;
END_VAR

VAR
    i       : INT;
    n_eff   : INT;
    slope   : FLOAT;
    found   : BOOL;
END_VAR

(* --- Inisialisasi status --- *)
Valid        := FALSE;
AuditFlag    := FALSE;
DensityValid := TRUE;
found        := FALSE;

IF NOT Enable THEN
    RETURN;
END_IF;

(* --- Kunci N dalam rentang aman [2..32] --- *)
n_eff := N;
IF n_eff &lt; 2 THEN
    n_eff := 2;
ELSIF n_eff &gt; 32 THEN
    n_eff := 32;
END_IF;

(* --- Validasi monotoni X_REF --- *)
FOR i := 0 TO n_eff - 2 DO
    IF X_REF[i] &gt; X_REF[i + 1] THEN
        DensityValid := FALSE;
    END_IF;
END_FOR;

(* --- Cari interval aktif --- *)
FOR i := 0 TO n_eff - 2 DO
    IF (X &gt;= X_REF[i]) AND (X &lt;= X_REF[i+1]) THEN
        X1_used := X_REF[i];     Y1_used := Y_REF[i];
        X2_used := X_REF[i+1];   Y2_used := Y_REF[i+1];
        found := TRUE;
        EXIT;
    END_IF;
END_FOR;

(* --- Clamp jika X di luar range --- *)
IF NOT found THEN
    IF X &lt; X_REF[0] THEN
        X1_used := X_REF[0];       Y1_used := Y_REF[0];
        X2_used := X_REF[1];       Y2_used := Y_REF[1];
    ELSIF X &gt; X_REF[n_eff - 1] THEN
        X1_used := X_REF[n_eff - 2]; Y1_used := Y_REF[n_eff - 2];
        X2_used := X_REF[n_eff - 1]; Y2_used := Y_REF[n_eff - 1];
    ELSE
        X1_used := X_REF[0];       Y1_used := Y_REF[0];
        X2_used := X_REF[1];       Y2_used := Y_REF[1];
    END_IF;
END_IF;

(* --- Hitung interpolasi linear --- *)
IF (X2_used - X1_used) = 0.0 THEN
    Y := Y1_used;
    Valid := FALSE;
ELSE
    slope := (Y2_used - Y1_used) / (X2_used - X1_used);
    Y := Y1_used + slope * (X - X1_used);
    Valid := TRUE;
END_IF;

(* --- Flag audit --- *)
IF (ABS(Y2_used - Y1_used) &gt; THRESHOLD) OR (NOT DensityValid) THEN
    AuditFlag := TRUE;
ELSE
    AuditFlag := FALSE;
END_IF;

END_FUNCTION_BLOCK
</code></pre>
<hr />

<h3 id="cara-penggunaan">Cara Penggunaan</h3>
<ol>
<li>Tentukan jumlah titik referensi aktual → set <code>N</code>.</li>
<li>Isi <code>X_REF[0..N-1]</code> dan <code>Y_REF[0..N-1]</code> dengan data kurva.</li>
<li>Biarkan <code>X_REF[N..31]</code> dan <code>Y_REF[N..31]</code> default (tidak dipakai).</li>
<li>Set <code>THRESHOLD</code> sesuai toleransi deviasi audit.</li>
<li>Aktifkan <code>Enable := TRUE</code>.</li>
</ol>
<hr />

<h3 id="contoh-tabel-input">Contoh Tabel Input</h3>
<table>
<thead>
<tr>
<th>Index</th>
<th>X_REF</th>
<th>Y_REF</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>10</td>
<td>5</td>
</tr>
<tr>
<td>2</td>
<td>20</td>
<td>15</td>
</tr>
<tr>
<td>3</td>
<td>30</td>
<td>25</td>
</tr>
<tr>
<td>4</td>
<td>40</td>
<td>35</td>
</tr>
<tr>
<td>5</td>
<td>50</td>
<td>50</td>
</tr>
</tbody>
</table>
<p>Jika <code>N = 6</code> dan <code>X = 22</code>, maka interval aktif <code>[20,30]</code> → hasil interpolasi <code>Y ≈ 17</code>.</p>
<hr />

<h3 id="flowchart-pairing">Flowchart Pairing</h3>
<div style="display: flex; flex-direction: column; align-items: center;">
  <div class="mermaid" style="width:100%; max-width:none; font-size:14px;">
    flowchart TD
        A(["Start"]) --&gt; B{"Enable?"}
        B -- "No" --&gt; Z(["Return"])
        B -- "Yes" --&gt; C["Set n_eff = N (clamp 2..32)"]
        C --&gt; D["Check monotoni X_REF"]
        D --&gt; E{"X in interval?"}
        E -- "Yes" --&gt; F["Set X1_used,Y1_used,X2_used,Y2_used"]
        E -- "No" --&gt; G{"X &lt; X_REF[0]?"}
        G -- "Yes" --&gt; H["Clamp ke interval awal"]
        G -- "No" --&gt; I{"X &gt; X_REF[n_eff-1]?"}
        I -- "Yes" --&gt; J["Clamp ke interval akhir"]
        I -- "No" --&gt; K["Fallback konservatif"]
        F --&gt; L{"Degenerate interval?"}
        H --&gt; L
        J --&gt; L
        K --&gt; L
        L -- "Yes" --&gt; M["Set Y=Y1_used, Valid=FALSE"]
        L -- "No" --&gt; N["Hitung slope dan Y, Valid=TRUE"]
        M --&gt; O{"Audit check"}
        N --&gt; O{"Audit check"}
        O -- "Deviasi &gt; THRESHOLD atau monotoni gagal" --&gt; P["AuditFlag=TRUE"]
        O -- "Normal" --&gt; Q["AuditFlag=FALSE"]
        P --&gt; Z(["End"])
        Q --&gt; Z(["End"])
  </div>
</div>
<hr />

<h3 id="kesimpulan">Kesimpulan</h3>
<p><code>K_LOOKUP_LINEAR</code> adalah artefak modular untuk interpolasi linear dinamis di Supcon DCS.<br />
Dengan fleksibilitas jumlah titik, proteksi multi-lapis, dan flag audit, FB ini memperkuat transparansi serta efisiensi sistem kontrol.</p>
<p>Mengapa hal ini penting bagi operasi plant?</p>
<ul>
<li><strong>Mengurangi duplikasi</strong>: tidak perlu lagi membuat FB statis dengan jumlah titik berbeda (misalnya 14, 20, dsb).</li>
<li><strong>Seragam lintas plant</strong>: format array 32 titik menjadi standar implementasi yang mudah diaudit dan diajarkan.</li>
<li><strong>Mempercepat commissioning</strong>: kurva peralatan baru dapat langsung dimasukkan tanpa modifikasi FB.</li>
<li><strong>Lebih aman</strong>: proteksi multi-lapis memastikan output stabil meski data referensi tidak sempurna.</li>
<li><strong>Audit-grade</strong>: adanya flag audit (<code>AuditFlag</code>, <code>DensityValid</code>) memberi transparansi penuh pada kualitas data dan hasil interpolasi.</li>
</ul>
<p>Sebagai ilustrasi nyata, lookup kurva <strong>anti-surge kompresor sentrifugal</strong> dengan 8–10 titik dapat langsung diakomodasi, tanpa harus menulis ulang FB baru seperti pada pendekatan statis <code>K_LIN_INTERP14</code>.</p>
<p><strong>Catatan praktis:</strong> Untuk anti-surge, interpolasi linear adalah pilihan terbaik karena:</p>
<ul>
<li>Perhitungan cepat dan ringan, tidak membebani CPU.</li>
<li>Mudah diverifikasi dan dipahami operator maupun engineer.</li>
<li>Transisi antar titik berjalan cepat sehingga stabil untuk kontrol real-time.</li>
<li>Cukup akurat untuk merepresentasikan performa kompresor di antara titik vendor.</li>
</ul>
<hr />

<h3 id="appendix-%E2%80%94-referensi-klininterp14">Appendix — Referensi <code>K_LIN_INTERP14</code></h3>
<ul>
<li><code>K_LIN_INTERP14</code> adalah <strong>versi statis</strong> dengan 14 titik, cocok untuk kurva performa yang sudah baku.</li>
<li><code>K_LOOKUP_LINEAR</code> adalah <strong>versi dinamis</strong> dengan jumlah titik fleksibel (2–32).</li>
<li>Menyertakan keduanya dalam artikel membantu pembaca memahami <strong>evolusi desain FB</strong> dari statis → dinamis, sekaligus memberi referensi audit.</li>
</ul>
<details>
<summary>K_LIN_INTERP14 Function Block (klik untuk membuka)</summary>
<pre><code class="language-pascal">(*=============================================================================
  Function Block Name : K_LIN_INTERP14
  Author              : Ketut P. Kumajaya
  Date Created        : 04/10/2025
  Description         : Melakukan interpolasi linear berdasarkan 14 pasang titik
                        (X0..X13, Y0..Y13). Umumnya digunakan untuk lookup
                        kurva performa peralatan proses (misalnya garis surge
                        centrifugal compressor).
  Inputs              : X        - Nilai input yang akan diinterpolasi (FLOAT)
                        X0..X13  - Koordinat X referensi (FLOAT)
                        Y0..Y13  - Koordinat Y referensi (FLOAT)
  Outputs             : Y        - Hasil interpolasi linear (FLOAT)
                        X1_used  - Titik awal X interval aktif (FLOAT)
                        Y1_used  - Titik awal Y interval aktif (FLOAT)
                        X2_used  - Titik akhir X interval aktif (FLOAT)
                        Y2_used  - Titik akhir Y interval aktif (FLOAT)
  Artefak Pairing     : X_ARRAY  - ARRAY [0..13] OF FLOAT
                        Y_ARRAY  - ARRAY [0..13] OF FLOAT
  Proteksi Audit      : Jika X di luar range, output dikunci pada ujung tabel.
                        Pembagian dengan nol dicegah dengan fallback ke nilai
                        tetap agar algoritma selalu stabil.
=============================================================================*)

FUNCTION_BLOCK K_LIN_INTERP14

VAR_INPUT
    X   : FLOAT;
    X0  : FLOAT;   Y0  : FLOAT;
    X1  : FLOAT;   Y1  : FLOAT;
    X2  : FLOAT;   Y2  : FLOAT;
    X3  : FLOAT;   Y3  : FLOAT;
    X4  : FLOAT;   Y4  : FLOAT;
    X5  : FLOAT;   Y5  : FLOAT;
    X6  : FLOAT;   Y6  : FLOAT;
    X7  : FLOAT;   Y7  : FLOAT;
    X8  : FLOAT;   Y8  : FLOAT;
    X9  : FLOAT;   Y9  : FLOAT;
    X10 : FLOAT;   Y10 : FLOAT;
    X11 : FLOAT;   Y11 : FLOAT;
    X12 : FLOAT;   Y12 : FLOAT;
    X13 : FLOAT;   Y13 : FLOAT;
END_VAR

VAR_OUTPUT
    X1_used : FLOAT;
    Y1_used : FLOAT;
    X2_used : FLOAT;
    Y2_used : FLOAT;
    Y       : FLOAT;
END_VAR

VAR
    X_ARRAY : array14FLOAT; (* user defined data type *)
    Y_ARRAY : array14FLOAT; (* user defined data type *)
    i       : INT;
    slope   : FLOAT;
END_VAR

(* --- Inisialisasi array --- *)
X_ARRAY[0] := X0;   Y_ARRAY[0] := Y0;
X_ARRAY[1] := X1;   Y_ARRAY[1] := Y1;
...
X_ARRAY[13] := X13; Y_ARRAY[13] := Y13;

(* --- Cari interval aktif --- *)
FOR i := 0 TO 12 DO
    IF (X &gt;= X_ARRAY[i]) AND (X &lt;= X_ARRAY[i+1]) THEN
        X1_used := X_ARRAY[i];   Y1_used := Y_ARRAY[i];
        X2_used := X_ARRAY[i+1]; Y2_used := Y_ARRAY[i+1];
        EXIT;
    END_IF;
END_FOR;

(* --- Clamp jika X di luar range --- *)
IF X &lt; X_ARRAY[0] THEN
    X1_used := X_ARRAY[0];   Y1_used := Y_ARRAY[0];
    X2_used := X_ARRAY[1];   Y2_used := Y_ARRAY[1];
ELSIF X &gt; X_ARRAY[13] THEN
    X1_used := X_ARRAY[12];  Y1_used := Y_ARRAY[12];
    X2_used := X_ARRAY[13];  Y2_used := Y_ARRAY[13];
END_IF;

(* --- Hitung interpolasi linear --- *)
IF (X2_used - X1_used) = 0 THEN
    Y := Y1_used; (* fallback jika interval degenerat *)
ELSE
    slope := (Y2_used - Y1_used) / (X2_used - X1_used);
    Y := Y1_used + slope * (X - X1_used);
END_IF;

END_FUNCTION_BLOCK
</code></pre>
</details>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="distributed-control-system" /><category term="Distributed Control System" /><category term="Practical Engineering" /><category term="Field Experience" /><summary type="html"><![CDATA[`K_LOOKUP_LINEAR` adalah Function Block modular untuk interpolasi linear dinamis. Dengan dukungan hingga 32 titik, proteksi berlapis, dan flag audit. Implementasi ini memudahkan standardisasi lookup kurva, mempercepat commissioning, dan memastikan transparansi hasil perhitungan dalam operasi plant.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1509228627152-72ae9ae6848d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDd8fG1hdGh8ZW58MHx8fHwxNzU5NTU1NjM4fDA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1509228627152-72ae9ae6848d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDd8fG1hdGh8ZW58MHx8fHwxNzU5NTU1NjM4fDA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">K_UNBALANCE: Function Block untuk Deteksi Ketidakseimbangan Tegangan/Arus di DCS</title><link href="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/03/k_unbalance-function-block-untuk-deteksi-ketidakseimbangan-tegangan-arus-di-dcs.html" rel="alternate" type="text/html" title="K_UNBALANCE: Function Block untuk Deteksi Ketidakseimbangan Tegangan/Arus di DCS" /><published>2025-10-03T09:04:31+00:00</published><updated>2025-10-03T09:04:31+00:00</updated><id>https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/03/k_unbalance-function-block-untuk-deteksi-ketidakseimbangan-tegangan-arus-di-dcs</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/10/03/k_unbalance-function-block-untuk-deteksi-ketidakseimbangan-tegangan-arus-di-dcs.html"><![CDATA[<p><strong>Oleh: Ketut P. Kumajaya — 3 Oktober 2025</strong></p>
<h3 id="latar-belakang">Latar Belakang</h3>
<p>Dalam sistem distribusi daya, ketidakseimbangan antar fase tegangan atau arus dapat menyebabkan panas berlebih, penurunan efisiensi, dan gangguan pada peralatan. Sayangnya, banyak power meter tidak menyediakan informasi unbalance secara langsung. Untuk menutup celah ini, Function Block <code>K_UNBALANCE</code> dirancang menggunakan Structured Text (ST) di Supcon DCS sebagai artefak modular yang siap diaudit dan teachable lintas operator.</p>
<hr />

<h3 id="struktur-function-block">Struktur Function Block</h3>
<pre><code class="language-pascal">(*=============================================================================
  Function Block Name : K_UNBALANCE
  Author              : Ketut P. Kumajaya
  Date Created        : 18/03/2025
  Description         : Menghitung persentase ketidakseimbangan dari tiga input
                        dan memberikan nilai rata-rata sebagai referensi audit.
                        Dirancang untuk melengkapi power meter yang tidak
                        menyediakan informasi unbalance.
  Inputs              : IN1 - Input pertama (FLOAT)
                        IN2 - Input kedua (FLOAT)
                        IN3 - Input ketiga (FLOAT)
  Outputs             : UNB - Persentase ketidakseimbangan (FLOAT)
                        AVG - Nilai rata-rata dari ketiga input (FLOAT)
  Artefak Pairing     : arrayUNB - ARRAY [0..2] OF FLOAT
  Proteksi Audit      : Pembagian dengan nol dicegah secara eksplisit.
                        Nilai absolut dari AVG digunakan sebagai denominator
                        untuk memastikan UNB selalu positif, termasuk pada
                        input negatif akibat noise atau simulasi.
=============================================================================*)

FUNCTION_BLOCK K_UNBALANCE

VAR_INPUT
    IN1 : FLOAT; (* Input pertama *)
    IN2 : FLOAT; (* Input kedua *)
    IN3 : FLOAT; (* Input ketiga *)
END_VAR

VAR_OUTPUT
    UNB : FLOAT; (* Persentase ketidakseimbangan *)
    AVG : FLOAT; (* Nilai rata-rata dari ketiga input *)
END_VAR

VAR
    AvgValue      : FLOAT;
    MaxDeviation  : FLOAT;
    Deviation     : FLOAT;
    i             : INT;
    Values        : arrayUNB; (* arrayUNB = ARRAY [0..2] OF FLOAT *)
END_VAR

(* Pairing input ke array *)
Values[0] := IN1;
Values[1] := IN2;
Values[2] := IN3;

(* Hitung nilai rata-rata *)
AvgValue := 0.0;
FOR i := 0 TO 2 DO
    AvgValue := AvgValue + Values[i];
END_FOR;
AvgValue := AvgValue / 3.0;

(* Cari deviasi maksimum terhadap rata-rata *)
MaxDeviation := 0.0;
FOR i := 0 TO 2 DO
    Deviation := ABS_FLOAT(Values[i] - AvgValue);
    IF Deviation &gt; MaxDeviation THEN
        MaxDeviation := Deviation;
    END_IF;
END_FOR;

(* Hitung unbalance dan kirim nilai rata-rata *)
IF AvgValue &lt;&gt; 0.0 THEN
    UNB := (MaxDeviation / ABS_FLOAT(AvgValue)) * 100.0;
ELSE
    UNB := 0.0; (* Proteksi pembagian dengan nol *)
END_IF;

AVG := AvgValue;

END_FUNCTION_BLOCK
</code></pre>
<hr />

<h3 id="penjelasan-modularitas">Penjelasan Modularitas</h3>
<p>FB ini menggunakan pendekatan array (<code>arrayUNB</code>) untuk menyimpan input, sehingga logika perhitungan menjadi ringkas dan konsisten. Looping untuk rata-rata dan deviasi maksimum dilakukan secara eksplisit, memudahkan validasi runtime dan audit pairing.</p>
<p>Output <code>UNB</code> menunjukkan persentase ketidakseimbangan, sedangkan <code>AVG</code> memberikan baseline referensi untuk analisis deviasi. Proteksi terhadap pembagian nol memastikan FB ini robust dan siap digunakan dalam sistem SCADA.</p>
<hr />

<h3 id="flowchart">Flowchart</h3>
<div style="width: 100%; text-align: center; margin: 0.5em auto; max-width: 800px;">
    <div class="mermaid" style="width: 100%; max-width: 800px;">
    flowchart TD
        IN1["IN1 (Input pertama)"]
        IN2["IN2 (Input kedua)"]
        IN3["IN3 (Input ketiga)"]
        ARRAY["Values : arrayUNB"]
        AVG_LOOP["Loop Hitung Rata-rata"]
        DEV_LOOP["Loop Deviasi Maksimum"]
        PROTEKSI["Proteksi: AvgValue ≠ 0"]
        HITUNG_UNB["Hitung UNB (%)"]
        OUTPUT_UNB["UNB (Output ketidakseimbangan)"]
        OUTPUT_AVG["AVG (Output rata-rata)"]
        IN1 --&gt; ARRAY
        IN2 --&gt; ARRAY
        IN3 --&gt; ARRAY
        ARRAY --&gt; AVG_LOOP
        AVG_LOOP --&gt; DEV_LOOP
        DEV_LOOP --&gt; PROTEKSI
        PROTEKSI --&gt;|True| HITUNG_UNB
        PROTEKSI --&gt;|False| OUTPUT_UNB
        HITUNG_UNB --&gt; OUTPUT_UNB
        AVG_LOOP --&gt; OUTPUT_AVG
    </div>
</div>
<hr />

<h3 id="kesimpulan">Kesimpulan</h3>
<p>Function Block <code>K_UNBALANCE</code> adalah artefak modular yang memperkuat transparansi dan efisiensi dalam sistem DCS. Dengan pairing array, proteksi multi-lapis, dan output yang informatif, FB ini bisa dijadikan template untuk pengembangan Function Block lain yang audit-grade dan teachable lintas plant.</p>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="distributed-control-system" /><category term="Distributed Control System" /><category term="Practical Engineering" /><category term="Field Experience" /><summary type="html"><![CDATA[Dirancang untuk menghitung ketidakseimbangan tegangan atau arus dari tiga input dalam sistem DCS, khususnya pada power meter yang tidak menyediakan informasi unbalance.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1536623975707-c4b3b2af565d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxiYWxhbmNlfGVufDB8fHx8MTc1OTQ4MTQ3Nnww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1536623975707-c4b3b2af565d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDEyfHxiYWxhbmNlfGVufDB8fHx8MTc1OTQ4MTQ3Nnww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Anchor-Based Normalization: Strategi Koreksi Drift Data Akumulator di DCS/SCADA</title><link href="https://kumajaya.github.io/automation-blog/measurement-accuracy/2025/09/27/anchor-based-normalization-strategi-koreksi-drift-data-akumulator-di-dcs-scada.html" rel="alternate" type="text/html" title="Anchor-Based Normalization: Strategi Koreksi Drift Data Akumulator di DCS/SCADA" /><published>2025-09-27T20:13:03+00:00</published><updated>2025-09-27T20:13:03+00:00</updated><id>https://kumajaya.github.io/automation-blog/measurement-accuracy/2025/09/27/anchor-based-normalization-strategi-koreksi-drift-data-akumulator-di-dcs-scada</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/measurement-accuracy/2025/09/27/anchor-based-normalization-strategi-koreksi-drift-data-akumulator-di-dcs-scada.html"><![CDATA[<p><em>Ditulis oleh Ketut Kumajaya | 28 September 2025</em></p>
<h2 id="pengantar">Pengantar</h2>
<p>Dalam sistem DCS/SCADA, drift data akumulasi adalah masalah klasik. Counter runtime, hour meter, atau energi meter sering mengalami penyimpangan akibat overflow tipe data, jitter komunikasi, atau perbedaan jam antar perangkat. Bias kecil yang dibiarkan akan menumpuk, menghasilkan data historis yang tidak konsisten dan menyimpang.</p>
<p>Contoh sederhana: akumulasi flowmeter menyimpang hingga 2% dari nilai seharusnya, tanpa ada yang menyadari.</p>
<p>Untuk mengatasi hal ini, artikel ini memperkenalkan pendekatan <strong>Anchor-Based Normalization</strong>: strategi koreksi berbasis satu titik referensi (anchor point) yang ditanam di DCS, dengan Rapid SCADA sebagai time authority dan Node-RED sebagai relay REST API yang melakukan koreksi on-demand.</p>
<p>Lebih dari sekadar normalisasi, pendekatan ini mewujudkan <strong>self-healing measurement pipeline</strong>, di mana sistem secara otomatis mendeteksi deviasi, menerapkan koreksi hanya saat diperlukan, dan menyimpan catatan audit secara transparan.</p>
<hr />

<h2 id="konsep-anchor-based-normalization">Konsep Anchor-Based Normalization</h2>
<ul>
<li><strong>Anchor Point</strong> → nilai referensi tunggal yang diketahui benar (misalnya input statis <code>flowrate = 3750</code>).</li>
<li><strong>Window Historis</strong> → data 4–24 jam terakhir dari Rapid SCADA digunakan untuk menghitung selisih (offset).</li>
<li><strong>Offset Correction</strong> → selisih antara anchor dan histori diterapkan ke semua accumulator.</li>
<li><strong>Normalization</strong> → setiap data yang diminta ERP atau sistem bisnis lain sudah terkoreksi, sementara data mentah tetap tersimpan di Rapid SCADA.</li>
</ul>
<p>Dengan cara ini, cukup satu anchor point untuk meluruskan seluruh accumulator.</p>
<hr />

<h2 id="zona-deviasi">Zona Deviasi</h2>
<p>Untuk menjaga keseimbangan antara presisi dan keandalan, digunakan logika tiga zona:</p>
<table>
<thead>
<tr>
<th>Zona</th>
<th>Kriteria Deviasi Relatif</th>
<th>Status Koreksi</th>
<th>Catatan Audit</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hijau</td>
<td>≤ stddev</td>
<td>Tidak diterapkan (<code>applied: false</code>)</td>
<td>Deviasi dianggap noise, data dilewatkan apa adanya</td>
</tr>
<tr>
<td>Kuning</td>
<td>&gt; stddev dan ≤ max</td>
<td>Diterapkan (<code>applied: true</code>)</td>
<td>Koreksi normal, offset dicatat di header</td>
</tr>
<tr>
<td>Merah</td>
<td>&gt; max</td>
<td>Tidak diterapkan (<code>applied: false</code>)</td>
<td>Data dianggap outlier, dilewatkan <em>as-is</em> dengan flag audit</td>
</tr>
</tbody>
</table>
<p>Contoh kasus: deviasi 0.1% masuk zona hijau sehingga tidak dikoreksi, deviasi 0.35% masuk zona kuning sehingga koreksi diterapkan, sedangkan deviasi 12.5% masuk zona merah sehingga data dilewatkan apa adanya dengan catatan audit.</p>
<hr />

<h2 id="contoh-numerik-anchor-based-normalization">Contoh Numerik Anchor-Based Normalization</h2>
<ul>
<li><strong>Anchor Point (DCS)</strong>: <code>flowrate = 3750</code></li>
<li><strong>Window Historis (SCADA 4 jam terakhir)</strong>: rata-rata akumulator terbaca <code>3737</code></li>
<li><strong>Offset</strong>:<br />
$$\text{Offset} = \frac{3737 - 3750}{3750} \times 100% = -0.35%$$</li>
</ul>
<p>Offset negatif di sini artinya histori terbaca <strong>lebih rendah</strong> dibanding anchor.</p>
<hr />

<h3 id="evaluasi-zona-deviasi">Evaluasi Zona Deviasi</h3>
<ul>
<li><strong>Threshold stddev</strong>: 0.20%</li>
<li><strong>Threshold max</strong>: 5.0%</li>
</ul>
<p>Maka:</p>
<ul>
<li>Deviasi relatif = <strong>0.35%</strong></li>
<li>Karena <code>0.20% &lt; 0.35% ≤ 5.0%</code>, maka masuk <strong>Zona Kuning</strong>.</li>
<li>Status: <strong>applied = true</strong> → koreksi offset diterapkan.</li>
</ul>
<hr />

<h3 id="payload-hasil-koreksi">Payload Hasil Koreksi</h3>
<pre><code class="language-json">"correction": {
  "applied": true,
  "relative_deviation": 0.35,
  "std_dev_threshold": 0.20,
  "max_threshold": 5.0
}
</code></pre>
<p>ERP atau sistem bisnis cukup membaca bagian <code>data[]</code> dengan tenang, karena hasil sudah terjamin sesuai header <code>correction</code>.</p>
<hr />

<h3 id="perbandingan-kasus-lain">Perbandingan Kasus Lain</h3>
<ul>
<li><strong>Deviasi 0.1%</strong> → ≤ 0.20% → <strong>Zona Hijau</strong> → tidak dikoreksi (<code>applied: false</code>).</li>
<li><strong>Deviasi 0.35%</strong> → antara 0.20% dan 5.0% → <strong>Zona Kuning</strong> → dikoreksi (<code>applied: true</code>).</li>
<li><strong>Deviasi 12.5%</strong> → &gt; 5.0% → <strong>Zona Merah</strong> → tidak dikoreksi, dilewatkan <em>as-is</em> dengan catatan audit.</li>
</ul>
<hr />

<h2 id="implementasi-payload">Implementasi Payload</h2>
<p>Informasi koreksi cukup ditaruh sekali di header. Data di bawah tetap bersih, hanya menampilkan nilai akumulator.</p>
<pre><code class="language-json">{
  "site": "SIG025",
  "description": "SIG Bekasi",
  "correction": {
    "applied": true,
    "relative_deviation": 0.35,
    "std_dev_threshold": 0.20,
    "max_threshold": 5.0
  },
  "data": [
    {
      "index": 0,
      "code": "FTLOX-01",
      "description": "[1294] LOX Flow Totalizer",
      "source": "[1294] LOX Flow Totalizer",
      "data": [
        {
          "value": 829908.5625,
          "timestamp": "2025-09-28T01:00:00+07:00"
        },
        {
          "value": 826878.5,
          "timestamp": "2025-09-28T00:00:00+07:00"
        },
        {
          "value": 823849.1875,
          "timestamp": "2025-09-27T23:00:00+07:00"
        }
        ...
</code></pre>
<hr />

<h2 id="visualisasi-alur-data">Visualisasi Alur Data</h2>
<figure>
    <div class="mermaid">
    flowchart TD
        A["DCS: Akumulator (Flow Totalizer)"] --&gt; B["Rapid SCADA: Simpan raw historis"]
        B --&gt; C["Node-RED: Ambil raw saat ERP request"]
        C --&gt; D["Bandingkan dengan Anchor"]
        D --&gt; E{"Zona deviasi?"}
        E --&gt;|"Hijau (&lt;= stddev)"| F["Applied: false"]
        E --&gt;|"Kuning (antara stddev dan max)"| G["Applied: true"]
        E --&gt;|"Merah (&gt; max)"| H["Applied: false"]
        F --&gt; I["Header correction"]
        G --&gt; I
        H --&gt; I
        I --&gt; J["ERP: Konsumsi payload"]
    </div>
<figcaption>Alur Anchor-Based Normalization: SCADA tetap menyimpan data mentah, Node-RED memutuskan zona deviasi, dan ERP selalu menerima data yang sudah diputuskan sesuai header koreksi.</figcaption>
</figure>
<hr />

<h2 id="kesimpulan">Kesimpulan</h2>
<p>Dengan Anchor-Based Normalization berbasis anchor point di DCS dan logika tiga zona deviasi, pipeline data menjadi lebih presisi karena drift wajar terkoreksi, lebih aman karena noise kecil diabaikan dan outlier besar dilewatkan, serta lebih transparan karena data mentah tetap utuh sementara catatan koreksi tersimpan jelas.</p>
<p>Pendekatan ini membuat sistem audit-ready, mudah diajarkan lintas operator, dan scalable untuk berbagai aplikasi industri, khususnya pada akumulator seperti flow totalizer.</p>
<p>Hasilnya, audit tidak lagi disibukkan membetulkan angka, melainkan dapat langsung fokus pada analisis operasional dan pemeriksaan lanjutan berbasis catatan koreksi.</p>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="measurement-accuracy" /><category term="Measurement Accuracy" /><category term="Distributed Control System" /><category term="Field Experience" /><summary type="html"><![CDATA[Dari DCS ke ERP, data akumulasi sering “melenceng” tanpa kita sadari. Anchor‑Based Normalization menghadirkan cara sederhana namun kuat: satu anchor point, tiga zona deviasi, hasilnya data presisi dan transparan lintas sistem.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1505778276668-26b3ff7af103?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDl8fEdQU3xlbnwwfHx8fDE3NTkwMDM3ODd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1505778276668-26b3ff7af103?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDl8fEdQU3xlbnwwfHx8fDE3NTkwMDM3ODd8MA&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">K_ACCUM: Solusi Presisi dan Efisien untuk Drift Akumulator di Modbus Controller</title><link href="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/09/25/k_accumulator-solusi-presisi-dan-efisien-untuk-drift-akumulator-di-modbus-controller.html" rel="alternate" type="text/html" title="K_ACCUM: Solusi Presisi dan Efisien untuk Drift Akumulator di Modbus Controller" /><published>2025-09-25T07:08:24+00:00</published><updated>2025-09-25T07:08:24+00:00</updated><id>https://kumajaya.github.io/automation-blog/distributed-control-system/2025/09/25/k_accumulator-solusi-presisi-dan-efisien-untuk-drift-akumulator-di-modbus-controller</id><content type="html" xml:base="https://kumajaya.github.io/automation-blog/distributed-control-system/2025/09/25/k_accumulator-solusi-presisi-dan-efisien-untuk-drift-akumulator-di-modbus-controller.html"><![CDATA[<p><em>Ditulis oleh Ketut Kumajaya | 25 September 2025</em></p>
<h2 id="latar-belakang">Latar Belakang</h2>
<p>Dalam sistem industri berbasis DCS/SCADA, akumulasi data flow adalah fondasi penting untuk perhitungan energi, OEE, hour meter, maupun audit produksi. Supcon menyediakan function block bawaan <code>TOTAL_ACCUM</code> untuk fungsi ini. Namun, ketika block tersebut dijalankan di Modbus controller, muncul masalah serius: <em>drift</em> akumulasi akibat keterbatasan clock internal dan jitter eksekusi.</p>
<p>Selain itu, terdapat keterbatasan komunikasi: hanya tersedia 128 alamat 32‑bit untuk transfer data dari main controller ke Modbus controller. Sinyal analog SFLOAT 12‑bit hanya menempati 16‑bit, sehingga satu alamat 32‑bit dapat menampung dua sinyal. Sebaliknya, satu akumulator penuh menempati seluruh 32‑bit, sehingga konsumsi alamat menjadi dua kali lebih besar. Jika seluruh akumulasi dipusatkan di main controller, alokasi alamat akan cepat habis. Oleh karena itu, diperlukan solusi yang tidak hanya hemat alamat, tetapi juga tetap menjaga presisi.</p>
<hr />

<h2 id="tantangan-teknis">Tantangan Teknis</h2>
<ul>
<li><strong>Drift akumulasi</strong>: <code>TOTAL_ACCUM</code> bawaan bergantung pada clock internal Modbus controller yang tidak sinkron dengan main controller.</li>
<li><strong>Keterbatasan alamat komunikasi</strong>: hanya tersedia 128 alamat 32‑bit untuk transfer data.</li>
<li><strong>Perbedaan kebutuhan ruang data</strong>: sinyal flow 12‑bit disimpan dalam 16‑bit word, sehingga satu alamat 32‑bit dapat menampung dua sinyal. Sebaliknya, satu akumulator penuh menempati seluruh 32‑bit, membuat konsumsi alamat dua kali lebih besar.</li>
<li><strong>Kebutuhan auditabilitas</strong>: operator membutuhkan hasil akumulasi yang transparan, dapat ditelusuri, dan mudah dipahami lintas shift.</li>
</ul>
<hr />

<h2 id="analisis-akar-masalah">Analisis Akar Masalah</h2>
<ul>
<li><strong>Drift akumulasi</strong> terjadi karena clock internal Modbus controller berbasis 16‑bit tidak disiplin dan tidak sinkron dengan main controller, sehingga perhitungan delta waktu rawan melompat atau melambat.</li>
<li><strong>Alamat cepat habis</strong> disebabkan oleh perbedaan kebutuhan ruang: sinyal analog bisa dipadatkan (2 sinyal per alamat 32‑bit), sedangkan akumulator selalu menghabiskan satu alamat penuh.</li>
<li><strong>Kurangnya visibilitas audit</strong> muncul karena block bawaan <code>TOTAL_ACCUM</code> tidak mengekspos delta waktu. Operator hanya melihat nilai total, tanpa jejak perhitungan detail.</li>
</ul>
<hr />

<h2 id="solusi-kaccum">Solusi: K_ACCUM</h2>
<p>Saya merancang function block custom bernama <strong>K_ACCUM</strong>, dengan fitur utama:</p>
<ul>
<li>Clock referensi dari main controller → bebas drift, sinkron lintas device.</li>
<li>Integrasi wrap‑aware → rollover 16‑bit ditangani aman.</li>
<li>Proteksi delta &amp; RATE → delta negatif atau terlalu besar diabaikan, RATE anomali difilter.</li>
<li>Kompatibilitas penuh → menyediakan output FLOAT yang bisa dikonversi ke structAccum menggunakan function block CONVERT_TO_ACCUM</li>
<li>Audit‑friendly → komentar inline, reserved field dapat digunakan untuk logging delta atau flag anomali.</li>
</ul>
<h3 id="diagram-alur-mermaid">Diagram Alur (Mermaid)</h3>
<div style="display: flex; flex-direction: column; align-items: center;">
    <div class="mermaid" style="width:100%; max-width:none; font-size:14px;">
    flowchart LR
        A["Input"] --&gt; B["Proteksi"]
        B --&gt; C["Akumulasi"]
        C --&gt; D["Output"]
        C --&gt; E["Persistensi"]
        subgraph Input
            A1["ENABLE (BOOL)"]
            A2["RATE (SFLOAT)"]
            A3["DELTA (UINT)"]
            A4["ACC_IN (structKAccum)"]
        end
        subgraph Proteksi
            B1["Wrap-aware Timer 16-bit"]
            B2["Guard DeltaSec &gt; 60 (Clamp/Discard)"]
            B3["Guard RATE anomali"]
        end
        subgraph Akumulasi
            C1["AccReal := AccReal + (RATE * DeltaSec)"]
            C2["Preserve remainder (SFLOAT)"]
            C3["ENABLE = FALSE → Freeze AccReal"]
        end
        subgraph Output
            D1["ACC_OUT (structKAcuum)"]
            D2["ALT_OUT (FLOAT)"]
        end
        subgraph Persistensi
            E1["ACC_OUT := incremented ACC_IN"]
        end
        A1 --&gt; B
        A2 --&gt; B
        A3 --&gt; B
        A4 --&gt; B
        B --&gt; B1 --&gt; C
        B --&gt; B2 --&gt; C
        B --&gt; B3 --&gt; C
        C --&gt; D
        C --&gt; E
    </div>
</div>
<hr />

<h2 id="detail-teknis">Detail Teknis</h2>
<ul>
<li><strong>Rekonstruksi nilai total</strong>: akumulasi <code>accum</code> dan <code>remainder</code>.</li>
<li><strong>Perhitungan delta waktu</strong>: wrap‑aware 16‑bit, dengan proteksi &gt;60 detik.</li>
<li><strong>Integrasi</strong>: <code>AccReal := AccReal + (RATE * DeltaSec)</code> dilakukan dalam FLOAT penuh.</li>
<li><strong>Fragmentasi kembali</strong>: meskipun struktur data berbeda dengan structAccum, konversi bisa dilakukan menggunakan block bawaan.</li>
<li><strong>Konversi ke SFLOAT di tahap akhir</strong>: akumulasi dijaga dalam FLOAT untuk presisi maksimum, lalu dipadatkan ke SFLOAT pada bagian akhir.</li>
</ul>
<hr />

<h2 id="catatan-teknis-structkaccum-dan-horizon-overflow">Catatan Teknis: structKAccum dan Horizon Overflow</h2>
<p>Selain presisi integrasi, salah satu aspek penting dari kompatibilitas <strong>K_ACCUM</strong> adalah bisa dikonversi ke <strong>structAccum</strong> bawaan Supcon, sehingga tidak ada masalah jika hasilnya ditampilkan ke HMI. Struktur data terdiri dari 2 field:</p>
<ul>
<li><strong>accum</strong> → long (32‑bit)</li>
<li><strong>remainder</strong> → pecahan (SFLOAT)</li>
</ul>
<p>Sedangkan struktur structAccum terdiri dari empat field:</p>
<ul>
<li><strong>accum1</strong> → low word (16‑bit)</li>
<li><strong>accum2</strong> → high word (16‑bit)</li>
<li><strong>remainder</strong> → pecahan (SFLOAT)</li>
<li><strong>reserved</strong> → dapat digunakan untuk logging atau flag anomali</li>
</ul>
<p>Dengan keduanya adalah kombinasi integer 32‑bit dan pecahan SFLOAT, baik structKAccum maupun structAccum memiliki karakteristik unik:</p>
<ul>
<li>
<p><strong>Horizon overflow ±136 tahun</strong><br />
Integer 32‑bit mampu menampung hingga 4,29 miliar detik. Overflow baru terjadi setelah lebih dari satu abad operasi kontinu. Praktis, operator tidak perlu melakukan reset manual untuk menghindari overflow.</p>
</li>
<li>
<p><strong>Independen dari skala input</strong><br />
Berapapun range engineering unit (misalnya 0–10.000 Nm³/h), sinyal tetap dipadatkan ke <strong>SFLOAT 0–1</strong> sebelum diakumulasi, lalu di-<em>back scaling</em> ke unit aslinya.</p>
</li>
<li>
<p><strong>Audit‑friendly</strong><br />
Nilai total dapat direkonstruksi dengan cara yang sama lintas block, sehingga konsistensi audit tetap terjaga.</p>
</li>
</ul>
<hr />

<h3 id="beralih-dari-kaccumulator-ke-kaccum">Beralih dari K_ACCUMULATOR ke K_ACCUM</h3>
<p>Salah satu alasan utama transisi dari K_ACCUMULATOR ke K_ACCUM adalah karena struktur <code>structAccum</code> bawaan Supcon menggunakan dua word 16‑bit (<code>accum1</code> dan <code>accum2</code>). Urutan bit/word ini ternyata <strong>tidak selalu konsisten</strong> (tergantung endianness, yaitu cara sistem menyusun byte dalam memori), sehingga hasil akumulasi bisa mendadak jatuh atau menurun. Untuk aplikasi audit jangka panjang, kondisi ini tidak bisa diterima karena membuat hasil akumulasi sulit diprediksi, dan kesalahan akumulasi tidak dapat ditoleransi.</p>
<p>Sebagai solusi, <code>K_ACCUM</code> dirancang menggunakan <strong><code>LONG</code> 32‑bit tunggal</strong> yang bebas dari ambiguitas bit order. Struktur ini tetap dilengkapi dengan <code>remainder</code> (SFLOAT) untuk menjaga presisi pecahan.</p>
<p>Dengan desain ini, <code>K_ACCUM</code> lebih stabil, tetap presisi, dan audit‑friendly.<br />
Konversi ke <code>structAccum</code> masih dimungkinkan jika diperlukan untuk kompatibilitas HMI, tetapi logika inti tetap aman di <code>structKAccum</code>.</p>
<hr />

<h3 id="dependensi-dan-ekstensi-modular-kaccum">Dependensi dan Ekstensi Modular K_ACCUM</h3>
<ul>
<li>
<p><strong>K_DELTA (Dependensi Waktu)</strong><br />
Menyediakan delta waktu wrap‑aware dari timer utama 16‑bit.<br />
→ Digunakan oleh K_ACCUM dan seluruh block turunan agar konsisten, presisi, dan audit‑friendly.</p>
</li>
<li>
<p><strong>K_ADD_ACCUM (Aggregator)</strong><br />
Menjumlahkan dua accumulator <code>structKAccum</code> menjadi satu total konsolidasi.<br />
Cocok untuk agregasi OEE lintas line, penggabungan energi dari beberapa sumber, atau chaining modular (shift → harian → bulanan).</p>
</li>
<li>
<p><strong>K_SUB_ACCUM (Differentiator)</strong><br />
Mengurangkan dua accumulator <code>structKAccum</code> untuk menyingkap selisih.<br />
Cocok untuk audit energi (supply–demand), neraca massa (inlet–outlet), atau analisis delta OEE. Jika dua accumulator yang sama dikurangkan, block ini berfungsi sebagai reset.</p>
</li>
</ul>
<h4 id="karakteristik-bersama">Karakteristik Bersama</h4>
<ul>
<li>Presisi terjaga dengan kombinasi <strong>LONG + SFLOAT</strong>.</li>
<li>Output utama tetap <code>structKAccum</code>, dengan <strong>ALT_OUT (FLOAT)</strong> sebagai alternatif cepat.</li>
<li>Audit‑friendly: hasil dapat direkonstruksi dengan cara yang sama seperti K_ACCUM.</li>
<li>Modular: operator cukup drag‑and‑drop block tanpa scripting manual.</li>
</ul>
<blockquote>
<p>Dengan K_DELTA sebagai <em>time backbone</em> dan K_ADD_ACCUM/K_SUB_ACCUM sebagai ekstensi, keluarga K_ACCUM membentuk arsitektur akumulasi modular yang presisi, efisien, dan siap audit lintas plant.</p>
</blockquote>
<hr />

<h3 id="implikasi-operasional">Implikasi Operasional</h3>
<ul>
<li><strong>Tidak perlu reset</strong> → operator terbebas dari prosedur reset akumulator yang berisiko menghapus histori.</li>
<li><strong>Data kontinu</strong> → histori akumulasi dapat berjalan tanpa interupsi, memudahkan analisis jangka panjang.</li>
<li><strong>Sederhana untuk transfer knowledge</strong> → operator baru cukup memahami bahwa akumulator akan terus bertambah, tanpa perlu menghafal SOP reset.</li>
</ul>
<blockquote>
<p>Dengan horizon overflow ±136 tahun, structKAccum praktis tidak memerlukan reset manual. Hal ini menghilangkan risiko kehilangan data akibat reset, sekaligus menyederhanakan SOP operator. Akumulator dapat berjalan kontinu, audit tetap konsisten, dan transfer knowledge lintas shift menjadi lebih mudah.</p>
</blockquote>
<hr />

<h2 id="potensi-ekstensi-fungsi">Potensi Ekstensi Fungsi</h2>
<table>
<thead>
<tr>
<th>Aplikasi</th>
<th>Konfigurasi RATE</th>
<th>Hasil</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hour Meter</td>
<td>RATE = 1.0 saat equipment ON</td>
<td>Akumulasi detik operasi → jam</td>
</tr>
<tr>
<td>Runtime Counter</td>
<td>RATE = 1 saat ON, 0 saat OFF</td>
<td>Total waktu ON untuk PM</td>
</tr>
<tr>
<td>Event Duration Logger</td>
<td>RATE = 1 saat kondisi tertentu</td>
<td>Total durasi kondisi aktif</td>
</tr>
<tr>
<td>Audit Energi</td>
<td>RATE = konsumsi energi per detik</td>
<td>Total energi (kWh)</td>
</tr>
</tbody>
</table>
<hr />

<h2 id="validasi-independen-dengan-rapid-scada">Validasi Independen dengan Rapid SCADA</h2>
<p>Untuk memastikan hasil tidak bias, pengujian dilakukan menggunakan Rapid SCADA sebagai sistem eksternal yang independen dari DCS.</p>
<ul>
<li><strong>Metode</strong>: flow statis 2500 diberikan secara identik ke K_ACCUM dan TOTAL_ACCUM dari variabel yang sama, lalu hasil ditrend di Rapid SCADA.</li>
<li><strong>Hasil</strong>:
<ul>
<li>K_ACCUM: 2499,3 (deviasi −0,03%)</li>
<li>TOTAL_ACCUM: 2450 (deviasi −2%)</li>
</ul>
</li>
<li><strong>Makna</strong>: bahkan dengan pengujian eksternal, in‑house FB terbukti lebih presisi dibanding block bawaan vendor.</li>
</ul>
<hr />

<h2 id="dampak-dan-nilai-tambah">Dampak dan Nilai Tambah</h2>
<ul>
<li>Efisiensi komunikasi → alamat 128 tidak cepat habis.</li>
<li>Presisi akumulasi → hasil konsisten, bebas drift jangka panjang.</li>
<li>Auditabilitas → operator dapat menelusuri delta waktu.</li>
<li>Fleksibilitas → block dapat digunakan sebagai accumulator, hour meter, runtime counter, maupun logger.</li>
<li>Kredibilitas eksternal → hasil diverifikasi oleh sistem independen (Rapid SCADA).</li>
</ul>
<hr />

<h2 id="kesimpulan">Kesimpulan</h2>
<p>K_ACCUM berhasil menurunkan deviasi dibanding block bawaan Supcon. Hasilnya memang tidak harus sempurna—karena faktor eksternal seperti jitter komunikasi dan keterbatasan representasi data tetap ada—tetapi penurunan deviasi dari 2% menjadi 0,03% adalah pencapaian nyata.</p>
<p>Solusi ini bukan sekadar “membuat block baru”, melainkan membangun arsitektur yang efisien, presisi, audit‑friendly, dan terbukti lebih baik bahkan saat diuji dengan sistem independen. Pencapaian ini menjadi basis kuat untuk benchmark jangka panjang, di mana performa K_ACCUM dapat diuji lebih lama (jam, hari, hingga minggu) untuk membuktikan stabilitasnya dalam kondisi operasi nyata.</p>
<hr />

<p><strong>Catatan kontributor:</strong> Artikel ini disusun oleh <strong>Ketut Kumajaya</strong> dengan dukungan editorial dari Copilot (Microsoft AI) dalam penyusunan narasi, struktur, dan dokumentasi teknis.</p>
<hr />

<h3 id="appendix-a-%E2%80%94-listing-kode-lengkap">Appendix A — Listing Kode Lengkap</h3>
<details>
<summary>Klik untuk membuka kode Function Block K_ACCUM</summary>
<pre><code class="language-pascal">
(*==============================================================================
FB Name     : K_ACCUM
Purpose     : Akumulator modular berbasis LONG + SFLOAT, menerima DELTA dari K_DELTA
Author      : Ketut Kumajaya
Contributor : Copilot (Microsoft AI)
Version     : 1.1 (tanpa RESET, dependensi ke K_DELTA)
Date        : 01/10/2025
Input       : ENABLE (BOOL)   - aktivasi akumulasi
              RATE   (SFLOAT) - laju akumulasi per detik
              DELTA  (UINT)   - selisih waktu antar siklus dari K_DELTA
              ACC_IN (structKAccum) - nilai akumulasi sebelumnya
Output      : ACC_OUT (structKAccum) - hasil akumulasi modular
              ALT_OUT (FLOAT)        - total nilai akumulasi sebagai alternatif
Notes       : - Input waktu TIMER telah digantikan oleh DELTA dari FB K_DELTA
              - K_ACCUM tidak menyimpan LAST_IN/OUT, sehingga lebih ringan
              - RATE dijaga dalam domain ±16 untuk stabilitas dan audit modular
              - Cocok untuk runtime, hour meter, OEE timer, dan akumulasi energi
              - Pairing waktu dan nilai dilakukan di artefak audit terpisah
Use-case    : Digunakan bersama K_DELTA untuk runtime modular lintas FB dan plant
==============================================================================*)

FUNCTION_BLOCK K_ACCUM
VAR_INPUT
    ENABLE : BOOL;
    RATE   : SFLOAT;
    DELTA  : UINT;
    ACC_IN : structKAccum;
END_VAR
VAR_OUTPUT
    ACC_OUT : structKAccum;
    ALT_OUT : FLOAT;
END_VAR
VAR
    AccReal : FLOAT;
    RateF   : FLOAT;
END_VAR

(* STEP 1: Rekonstruksi total dari input *)
AccReal := LONG_TO_FLOAT(ACC_IN.accum) + SFLOAT_TO_FLOAT(ACC_IN.remainder);

(* STEP 2: Integrasi normal *)
RateF := SFLOAT_TO_FLOAT(RATE);
IF ENABLE THEN
    IF (RateF &gt; -16.0) AND (RateF &lt; 16.0) THEN
        IF DELTA &gt; 0 THEN
            AccReal := AccReal + (RateF * UINT_TO_FLOAT(DELTA));
        END_IF;
    END_IF;
END_IF;

(* STEP 3: Pisahkan kembali ke integer + pecahan *)
ACC_OUT.accum     := FLOAT_TO_LONG(AccReal);
ACC_OUT.remainder := FLOAT_TO_SFLOAT(AccReal - LONG_TO_FLOAT(ACC_OUT.accum));

(* STEP 4: Output alternatif total *)
ALT_OUT := AccReal;

END_FUNCTION_BLOCK

</code></pre>
</details>
<details>
<summary>Klik untuk membuka kode Function Block K_DELTA</summary>
<pre><code class="language-pascal">(*==============================================================================
FB Name     : K_DELTA
Purpose     : Menghitung delta waktu wrap-aware dari timer utama (UINT 16-bit)
Author      : Ketut Kumajaya
Version     : 1.2 (IF-THEN-ELSE, no MOD)
Date        : 07/10/2025
Input       : TIMER_IN (UINT), LAST_IN (UINT)
Output      : DELTA_OUT (UINT), LAST_OUT (UINT), ALARM_OUT (BOOL)
Notes       : - IF-THEN-ELSE untuk hindari loncatan MOD
              - Cutoff 60 detik; LONG untuk Supcon-safe
              - Persisten global LAST_IN/OUT
==============================================================================*)

FUNCTION_BLOCK K_DELTA
VAR_INPUT
    TIMER_IN : UINT;
    LAST_IN  : UINT;
END_VAR
VAR_OUTPUT
    DELTA_OUT : UINT;
    LAST_OUT  : UINT;
    ALARM_OUT : BOOL;
END_VAR
VAR
    Delta       : LONG;
    StartupFlag : BOOL;
END_VAR

StartupFlag := g_bColdStartup OR g_bHotStartup OR g_bDownUsrPrgFlag OR g_bDownCfgFlag;

IF StartupFlag THEN
    Delta := 0;
    ALARM_OUT := FALSE;
    g_bColdStartup := FALSE;
    g_bHotStartup := FALSE;
    g_bDownUsrPrgFlag := FALSE;
    g_bDownCfgFlag := FALSE;
ELSE
    IF TIMER_IN &gt;= LAST_IN THEN
        Delta := ULONG_TO_LONG(UINT_TO_ULONG(TIMER_IN)) - ULONG_TO_LONG(UINT_TO_ULONG(LAST_IN));
    ELSE
        Delta := ULONG_TO_LONG(UINT_TO_ULONG(65535 - LAST_IN)) + ULONG_TO_LONG(UINT_TO_ULONG(TIMER_IN)) + 1;
    END_IF;

    IF Delta &gt; 60 THEN
        Delta := 0;
        ALARM_OUT := TRUE;
    ELSE
        ALARM_OUT := FALSE;
    END_IF;
END_IF;

DELTA_OUT := ULONG_TO_UINT(LONG_TO_ULONG(Delta));
LAST_OUT  := TIMER_IN;

END_FUNCTION_BLOCK

</code></pre>
</details>
<details>
<summary>Klik untuk membuka kode Function Block K_ADD_ACCUM</summary>
<pre><code class="language-pascal">(*==============================================================================
 FB Name     : K_ADD_ACCUM
 Purpose     : Menjumlahkan dua accumulator (structKAccum) secara modular
 Author      : Ketut Kumajaya
 Contributor : Copilot (Microsoft AI)
 Version     : 1.0 (initial release)
 Date        : 28/09/2025
 Input       : ACC1 (structKAccum), ACC2 (structKAccum)
 Output      : ACC_OUT (structKAccum), ALT_OUT (FLOAT total)
 Notes       : - Presisi dijaga dengan LONG + SFLOAT
               - ALT_OUT = total float alternatif
               - Cocok untuk merge runtime, energy, atau counter modular
 Use-case    : Penjumlahan antar accumulator, agregasi OEE, chaining modular
==============================================================================*)

FUNCTION_BLOCK K_ADD_ACCUM
VAR_INPUT
    ACC1 : structKAccum;
    ACC2 : structKAccum;
END_VAR
VAR_OUTPUT
    ACC_OUT : structKAccum;
    ALT_OUT : FLOAT;
END_VAR
VAR
    SumReal : FLOAT;
END_VAR

(* STEP 1: Rekonstruksi total dari masing-masing input *)
SumReal := LONG_TO_FLOAT(ACC1.accum) + SFLOAT_TO_FLOAT(ACC1.remainder)
         + LONG_TO_FLOAT(ACC2.accum) + SFLOAT_TO_FLOAT(ACC2.remainder);

(* STEP 2: Pisahkan kembali ke integer + pecahan *)
ACC_OUT.accum     := FLOAT_TO_LONG(SumReal);
ACC_OUT.remainder := FLOAT_TO_SFLOAT(SumReal - LONG_TO_FLOAT(ACC_OUT.accum));

(* STEP 3: Output alternatif total *)
ALT_OUT := SumReal;

END_FUNCTION_BLOCK

</code></pre>
</details>

<details>
<summary>Klik untuk membuka kode Function Block K_SUB_ACCUM</summary>
<pre><code class="language-pascal">(*==============================================================================
 FB Name     : K_SUB_ACCUM
 Purpose     : Mengurangkan dua accumulator (structKAccum) secara modular
 Author      : Ketut Kumajaya
 Contributor : Copilot (Microsoft AI)
 Version     : 1.0 (initial release)
 Date        : 28/09/2025
 Input       : ACC1 (structKAccum), ACC2 (structKAccum)
 Output      : ACC_OUT (structKAccum), ALT_OUT (FLOAT total)
 Notes       : - Presisi dijaga dengan LONG + SFLOAT
               - ALT_OUT = total float alternatif
               - Cocok untuk selisih runtime, energy, atau counter modular
 Use-case    : Pengurangan antar accumulator, analisis delta OEE, chaining modular
==============================================================================*)

FUNCTION_BLOCK K_SUB_ACCUM
VAR_INPUT
    ACC1 : structKAccum;
    ACC2 : structKAccum;
END_VAR
VAR_OUTPUT
    ACC_OUT : structKAccum;
    ALT_OUT : FLOAT;
END_VAR
VAR
    DiffReal : FLOAT;
END_VAR

(* STEP 1: Rekonstruksi total dari masing-masing input *)
DiffReal := (LONG_TO_FLOAT(ACC1.accum) + SFLOAT_TO_FLOAT(ACC1.remainder))
          - (LONG_TO_FLOAT(ACC2.accum) + SFLOAT_TO_FLOAT(ACC2.remainder));

(* STEP 2: Pisahkan kembali ke integer + pecahan *)
ACC_OUT.accum     := FLOAT_TO_LONG(DiffReal);
ACC_OUT.remainder := FLOAT_TO_SFLOAT(DiffReal - LONG_TO_FLOAT(ACC_OUT.accum));

(* STEP 3: Output alternatif total *)
ALT_OUT := DiffReal;

END_FUNCTION_BLOCK

</code></pre>
</details>
<details>
<summary>Klik untuk membuka kode Function Block legacy K_ACCUMULATOR</summary>
<pre><code class="language-pascal">
(*
==============================================================================
 Function Block : K_ACCUMULATOR
 Deskripsi      : Integrator berbasis laju per detik (SFLOAT) dan free-running
                  timer 16-bit, kompatibel Supcon structAccum
 Penulis        : Ketut Kumajaya
 Kontributor    : Copilot (Microsoft AI)
 Versi          : 1.1
 Tanggal        : 25/09/2025
==============================================================================

Fungsi:
- Mengakumulasi nilai = RATE * DeltaSec setiap scan.
- Menggunakan external clock T_IN (0..65535 detik, wrap-aware).
- Reset penuh ditangani oleh built-in FB Supcon melalui structAccum.
- Proteksi delta waktu: delta negatif atau terlalu besar (&gt;60 detik) diabaikan.
- Guard RATE: nilai anomali (-16 &gt; RATE &gt; 16) diabaikan.
- Struktur kompatibel dengan accumulator built-in Supcon.

Versi 1.1 (26/09/2025)
- AccInt diganti ke tipe LONG → konversi lebih sederhana dan mendukung nilai negatif
- Validasi remainder selalu dinormalisasi ke [0,1)
- Patch encoding low word → dipaksa unsigned (0..65535) agar kompatibel penuh dengan structAccum
- Eliminasi bug “accum1 = –32768” yang menyebabkan akumulasi tampak menurun
==============================================================================
*)

FUNCTION_BLOCK K_ACCUMULATOR
VAR_INPUT
    RATE     : SFLOAT;       (* Laju per detik (unit/s) *)
    T_IN     : UINT;         (* Free-running timer (0..65535 detik) *)
    ACC_IN   : structAccum;  (* Akumulator persisten input *)
    LAST_IN  : UINT;         (* Snapshot timer sebelumnya *)
END_VAR
VAR_OUTPUT
    ACC_OUT  : structAccum;  (* Akumulator hasil update *)
    LAST_OUT : UINT;         (* Snapshot timer berikutnya *)
END_VAR
VAR
    AccReal   : FLOAT;       (* Rekonstruksi total accumulator *)
    AccInt    : LONG;        (* Bagian integer dari AccReal *)
    AccFrac   : FLOAT;       (* Bagian pecahan dari AccReal *)
    DeltaSec  : UINT;        (* Selisih detik antar scan *)
    RateF     : FLOAT;       (* RATE dalam FLOAT *)
    LowWord   : WORD;
    HighWord  : INT;
END_VAR

(* NOTE: accum1 = low word, accum2 = high word, remainder = fractional part *)
(* EVENT: Rekonstruksi nilai total dari ACC_IN *)
AccInt := INT_TO_LONG(WORD_TO_INT(INT_TO_WORD(ACC_IN.accum1)))
        + DWORD_TO_LONG(
            SHL_DWORD(LONG_TO_DWORD(INT_TO_LONG(ACC_IN.accum2)),
                16));                         (* shift high word 16 bit *)
AccFrac := SFLOAT_TO_FLOAT(ACC_IN.remainder); (* fractional part *)
AccReal := LONG_TO_FLOAT(AccInt) + AccFrac;   (* total accumulator *)

(* PROTEKSI: hitung delta dengan wrap 16-bit (modular, no-branch) *)
DeltaSec := (T_IN + 65536 - LAST_IN) MOD 65536;

(* PROTEKSI: guard delta anomali *)
IF DeltaSec &gt; 60 THEN
    DeltaSec := 0;
END_IF;

(* PROTEKSI: guard RATE anomali sesuai domain SFLOAT 12-bit: -16..+16 *)
RateF := SFLOAT_TO_FLOAT(RATE);
IF (RateF &lt; 16) AND (RateF &gt; -16) THEN
    IF DeltaSec &gt; 0 THEN
        AccReal := AccReal + (RateF * UINT_TO_FLOAT(DeltaSec));
    END_IF;
END_IF;

(* EVENT: Pisahkan kembali ke structAccum *)
AccInt  := FLOAT_TO_LONG(AccReal);
AccFrac := AccReal - LONG_TO_FLOAT(AccInt);

(* Normalisasi remainder ke [0,1) *)
IF AccFrac &lt; 0.0 THEN
    AccInt  := AccInt - 1;
    AccFrac := AccFrac + 1.0;
ELSE
    IF AccFrac &gt;= 1.0 THEN
        AccInt  := AccInt + 1;
        AccFrac := AccFrac - 1.0;
    END_IF;
END_IF;

(* NOTE: LowWord dipaksa unsigned (0..65535) agar kompatibel dengan structAccum.
   HighWord tetap signed. Total AccInt = HighWord*65536 + LowWord. *)
LowWord  := INT_TO_WORD(LONG_TO_INT(AccInt MOD 65536)); (* selalu 0..65535 *)
HighWord := LONG_TO_INT(AccInt / 65536);                (* high word bisa signed *)

ACC_OUT.accum1    := WORD_TO_INT(LowWord); (* low word aman, tidak pernah -32768 *)
ACC_OUT.accum2    := HighWord;             (* high word signed *)
ACC_OUT.remainder := FLOAT_TO_SFLOAT(AccFrac);
ACC_OUT.reserved  := 0.0;

(* Persist snapshot untuk scan berikutnya *)
LAST_OUT := T_IN;

END_FUNCTION_BLOCK

</code></pre>
</details>
<h3 id="appendix-b-%E2%80%94-extended-validation-runtime-1%E2%80%936-jam">Appendix B — Extended Validation Runtime (1–6 Jam)</h3>
<p>Pengujian runtime lebih panjang dilakukan dengan flow statis 2500 untuk melihat pola drift akumulasi secara progresif.</p>
<h4 id="hasil-pengujian-runtime">Hasil Pengujian Runtime</h4>
<table>
<thead>
<tr>
<th>Runtime</th>
<th>Ideal</th>
<th>K_ACCUM</th>
<th>Deviasi Absolut</th>
<th>Deviasi Relatif</th>
<th>TOTAL_ACCUM</th>
<th>Deviasi Absolut</th>
<th>Deviasi Relatif</th>
</tr>
</thead>
<tbody>
<tr>
<td>1 jam</td>
<td>2500</td>
<td>2499.31</td>
<td>−0.694</td>
<td>−0.028%</td>
<td>2450.69</td>
<td>−49.306</td>
<td>−1.972%</td>
</tr>
<tr>
<td>2 jam</td>
<td>5000</td>
<td>5002.08</td>
<td>+2.083</td>
<td>+0.042%</td>
<td>4905.56</td>
<td>−94.444</td>
<td>−1.898%</td>
</tr>
<tr>
<td>3 jam</td>
<td>7500</td>
<td>7500.69</td>
<td>+0.694</td>
<td>+0.009%</td>
<td>7355.56</td>
<td>−144.445</td>
<td>−1.926%</td>
</tr>
<tr>
<td>4 jam</td>
<td>10000</td>
<td>10000.69</td>
<td>+0.694</td>
<td>+0.007%</td>
<td>9806.94</td>
<td>−193.056</td>
<td>−1.931%</td>
</tr>
<tr>
<td>5 jam</td>
<td>12500</td>
<td>12500.00</td>
<td>+0.000</td>
<td>+0.000%</td>
<td>12258.33</td>
<td>−241.667</td>
<td>−1.933%</td>
</tr>
<tr>
<td>6 jam</td>
<td>15000</td>
<td>14998.61</td>
<td>−1.389</td>
<td>−0.009%</td>
<td>14708.33</td>
<td>−291.666</td>
<td>−1.944%</td>
</tr>
</tbody>
</table>
<h4 id="interpretasi">Interpretasi</h4>
<ul>
<li><strong>K_ACCUM</strong>: deviasi relatif tetap &lt;0.05% bahkan hingga 6 jam, menunjukkan presisi tinggi dan stabilitas jangka panjang.</li>
<li><strong>TOTAL_ACCUM</strong>: drift konsisten di sekitar −1.9% sejak awal hingga 6 jam, menegaskan bias bawaan block vendor.</li>
<li><strong>Makna audit</strong>: tren progresif ini memperkuat klaim bahwa K_ACCUM bukan hanya presisi sesaat, tetapi juga tahan drift dalam runtime panjang.</li>
</ul>]]></content><author><name>[&quot;Ketut Kumajaya&quot;]</name></author><category term="distributed-control-system" /><category term="Distributed Control System" /><category term="Practical Engineering" /><category term="Field Experience" /><summary type="html"><![CDATA[K_ACCUM adalah function block custom untuk mengatasi drift akumulasi dan keterbatasan alamat komunikasi antar controller. Dengan akumulasi tipe data LONG dengan nilai desimal dalam SFLOAT, solusi ini lebih presisi, hemat alamat, dan mudah ditangani.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="https://images.unsplash.com/photo-1633265486501-0cf524a07213?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDd8fHRpbWVyfGVufDB8fHx8MTc1ODc4NTc5NXww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" /><media:content medium="image" url="https://images.unsplash.com/photo-1633265486501-0cf524a07213?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=M3wxMTc3M3wwfDF8c2VhcmNofDd8fHRpbWVyfGVufDB8fHx8MTc1ODc4NTc5NXww&amp;ixlib=rb-4.1.0&amp;q=80&amp;w=2000" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>